---
title: "A fault-tolerant neutral-atom architecture for universal quantum computation | Nature"
source: https://www.nature.com/articles/s41586-025-09848-5
date: 2022-05-25
description: "Quantum error correction (QEC)1,2 is essential for the realization of large-scale quantum computers3,4. However, owing to the complexity of operating on the encoded ‘logical’ qubits5,6, understanding "
word_count: 28344
---

## Your privacy, your choice
We use essential cookies to make sure the site can function. We also use optional cookies for advertising, personalisation of content, usage analysis, and social media, as well as to allow video information to be shared for both marketing, analytics and editorial purposes.
By accepting optional cookies, you consent to the processing of your personal data - including transfers to third parties. Some third parties are outside of the European Economic Area, with varying standards of data protection.
See our privacy policy for more information on the use of your personal data.
Manage preferences for further information and to change your choices.
Accept all cookies Reject optional cookies
Skip to main content
Thank you for visiting nature.com. You are using a browser version with limited support for CSS. To obtain the best experience, we recommend you use a more up to date browser (or turn off compatibility mode in Internet Explorer). In the meantime, to ensure continued support, we are displaying the site without styles and JavaScript.
A fault-tolerant neutral-atom architecture for universal quantum computation 
 Download PDF 
 Download PDF 
## Abstract
Quantum error correction (QEC)1."),2.") is essential for the realization of large-scale quantum computers3."),4."). However, owing to the complexity of operating on the encoded ‘logical’ qubits5."),6."), understanding the physical principles for building fault-tolerant quantum devices and combining them into efficient architectures is an outstanding scientific challenge. Here we use reconfigurable arrays of up to 448 neutral atoms to implement the key elements of a universal, fault-tolerant quantum processing architecture and experimentally explore their underlying working mechanisms. We first use surface codes to study how repeated QEC suppresses errors6."),7."), demonstrating 2.14(13)x below-threshold performance in a four-round characterization circuit by leveraging atom loss detection and machine learning decoding8."),9."). We then investigate logical entanglement using transversal gates and lattice surgery10."),11."),12.") and extend it to universal logic through transversal teleportation with three-dimensional [[15,1,3]] codes13."),14."), enabling arbitrary-angle synthesis with polylogarithmic overhead5."),15."). Finally, we develop mid-circuit qubit reuse16."), increasing experimental cycle rates by two orders of magnitude and enabling deep-circuit protocols with dozens of logical qubits and hundreds of logical teleportations17."),18."),19."),20.") with [[7,1,3]] and high-rate [[16,6,4]] codes while maintaining constant internal entropy. Our experiments show key principles for efficient architecture design, involving the interplay between quantum logic and entropy removal, judiciously using physical entanglement in logic gates and magic state generation, and leveraging teleportations for universality and physical qubit reset. These results establish foundations for scalable, universal error-corrected processing and its practical implementation in neutral atom systems.
### Similar content being viewed by others

###  Logical quantum processor based on reconfigurable atom arrays 
Article Open access 06 December 2023

###  Realizing repeated quantum error correction in a distance-three surface code 
Article 25 May 2022

###  Low-overhead transversal fault tolerance for universal quantum computation 
Article 24 September 2025
## Main
The central challenge of quantum computation is its inherent sensitivity to errors4."),21."). Whereas classical computers are composed of intrinsically robust digital bits stabilized by dissipation22."), quantum states are intrinsically analog objects that evolve in a continuous state space, with coherent unitary evolution that does not allow dissipation21."). The discovery of quantum error correction (QEC)2."),23."),24.") provides a method to realize robust quantum computation. In this approach, entanglement between many physical qubits is used to encode error-corrected ‘logical’ qubits that can have exponentially low error rate while performing arbitrary computations1."),5.").
Although recent experiments provide examples in which QEC works in practice7."),11."),25."), large-scale fault-tolerant quantum computation (FTQC) remains a formidable challenge. In essence, we must dissipatively remove errors from the physical system, while simultaneously performing arbitrary coherent manipulation of the encoded logical qubits. This operation requires a broad range of components26."),27."), coupled with many important hardware considerations and a wide range of QEC techniques12."),28."),29."),30."),31."). Implementing and combining these techniques in practical systems, and understanding the scientific principles of resulting fault-tolerant architectures, is a highly complex task at the frontier of quantum science.
Here we experimentally implement the core building blocks for scalable, universal quantum computation and identify and explore key mechanisms for efficient architectures suitable for deep-circuit FTQC. Using a quantum processor based on reconfigurable neutral atom arrays and leveraging key hardware upgrades, we study below-threshold error correction, fault-tolerant quantum operations, arbitrary unitary synthesis and physical error removal during deep-circuit execution, altogether achieving all ingredients for scalable (that is, polylogarithmic overhead) realization of arbitrary quantum algorithms5."). Our results further advance the quantum computing frontier along several directions: (1) advanced decoding methods leveraging erasure information8."),9.") and machine learning32.") are used to optimize below-threshold performance; (2) syndrome measurements and physical entanglement are reduced to being used only where they are needed during universal logic; (3) teleportation17."),18."),19."),20.") is used to achieve efficient universality with transversal operations and enable physical qubit reset without additional overhead in the algorithm. These result in marked improvements in architecture design and orders-of-magnitude reduction in space and time overheads.
## Neutral atom logical processor
To implement these core building blocks, our experiments use a logical processor11.") with up to 448 atoms. Qubits are stored in the hyperfine clock states of 87Rb atoms trapped in optical tweezers generated by a spatial light modulator (SLM) in storage, entangling, readout and reservoir zones (Fig. 1a). Quantum circuits are programmed by shuttling qubits in the middle of the computation with a two-dimensional (2D) acousto-optic deflector33."),34."),35."), high-fidelity entangling operations are realized by fast excitation to Rydberg states36."), and fully programmable single-qubit operations are realized by locally focused Raman beams11."). This system provides control parallelism over logical qubit blocks11."): for logic gates, repeated error correction and even universal computation, all the physical qubits within the logical block realize identical operations with parallel instructions delivered by optical controls.
**Fig. 1: Architectures and mechanisms for FTQC.**

**a** , We study the key building blocks of fault-tolerant processing. We use an architecture based on reconfigurable atom arrays trapped in optical tweezers, in which the logical processor is segmented into storage, entangling, readout and reservoir zones. Underlying physical mechanisms are identified and characterized. **b** , Spin-to-position conversion for non-destructive, loss-resolved qubit readout is accomplished with a state-selective 1D lattice that converts the atom spin state into position. The plot shows measured Rabi oscillation. This non-destructive readout has 0.46(4)% bit-flip error and 0.24(2)% loss (Methods). **c** ,**d** , Stabilizer measurement on a _d_ = 5 surface code is interspersed with global coherent errors injected on the data qubits. Each CZ layer corresponds to one time step (Methods). Repeated stabilizer measurement reduces error build-up through both the Zeno effect and error tracking between rounds (right plot is at a fixed _θ_ /2π = 0.016). For visual clarity, an acceptance fraction of 50% is used in this plot (Methods).
Full size image
A key experimental upgrade involves non-destructive, spin-resolved qubit readout using a one-dimensional (1D) optical lattice in the readout zone (Fig. 1b). Whereas conventional readout is realized by spin-to-loss conversion followed by camera readout11."), the state-selective lattice enables splitting the two qubit states into two separate tweezers16."), thereby realizing spin-to-position conversion that enables both loss detection and atom retention. Combined with techniques for mid-circuit re-initialization, this enables qubit reuse for extended computation as well as a two orders of magnitude increase to the experimental cycle rate, as described below.
Another key addition involves the use of repeated error correction for removing errors produced during quantum algorithms. To probe this function of QEC, we use a distance-5 surface code logical qubit6."),7.") with up to five rounds of stabilizer measurement (Fig. 1c,d). Here, data qubits are held in static potentials in the entangling zone, and an ancilla block is moved over to perform parallel entangling operations required for measurements of stabilizers. After performing the stabilizer checks, the ancilla block is moved to the storage zone, and a new block is brought in to repeat the cycle. On injecting global coherent errors at regular intervals, we find repeated correction significantly suppresses logical errors, as coherent errors are projected into incoherent ones (with quadratic suppression) due to the quantum Zeno effect37.") and tracked. Notably, although the coherent errors are injected as global, correlated single-qubit rotations, stabilizer measurements convert these into uncorrelated, incoherent physical errors38.") and prevent coherent errors on the logical qubit level (Methods). Figure 1d highlights the function of repeated QEC: the conversion of general errors to correctable bit-flip and phase-flip errors removes entropy by reducing the range of possible errors5."), and detecting the incoherent errors and using them in decoding reduces entropy by keeping track of the state of the system6.").
## Below-threshold performance
We first use these tools to explore below-threshold performance of a surface code qubit under multiple rounds of QEC. Theoretically, logical errors can be exponentially suppressed as \\({(p/{p}_{{\rm{th}}})}^{(d+1)/2}\\) by increasing code distance _d_ if the physical error rate _p_ is below a characteristic threshold _p_ th, that is, below-threshold performance5."),6."),7."). Figure 2a shows the measurement results of the data qubits and multiple sets of ancilla qubits in the configuration shown in Fig. 1c, obtained with non-destructive, spin-resolved readout (Fig. 1b), which identifies which atoms were lost during the quantum circuit. We observe that qubit loss events result in flickering stabilizer patterns39.") (Methods and Extended Data Fig. 5b), which create time correlations between detected error events and leads to a sharp rise in detected errors (Fig. 2b).
**Fig. 2: Below-threshold repeated QEC leveraging loss detection.**

**a** , Results of repeated rounds of _d_ = 5 surface code using loss detection, showing a snapshot of the data block and multiple ancilla blocks (Extended Data Fig. 6). **b** ,**c** , Products of stabilizer measurement results between rounds are used to detect qubit errors, which we refer to as ‘detectors’. ‘Bare’ counts loss as state |0⟩, ‘detect loss’ does not make this erroneous assignment, ‘supercheck’ multiplies detectors around lost atoms, and ‘postselect’ postselects on all atoms of individual detectors being present. Detector error probability as a function of measured data qubit loss in each shot, analysed by partitioning the total dataset (**b**), and average over all data (**c**) are presented. **d** , Logical error per round for a surface code after four QEC rounds in both bases, decoded using most-likely error (‘bare MLE’) methods, machine learning (‘bare ML’), MLE with loss information and machine learning with loss information. Machine learning with loss renders the error per round for _d_ = 5 as 2.14(13)x lower than _d_ = 3. No postselection is used. Small points are the four _d_ = 3 quadrants. Results are averaged between |+_L_ ⟩ and |0 _L_ ⟩ initialization bases (see Methods and Extended Data Fig. 6 for more details). **e** , Logical error per round as a function of the mean qubit loss, plotted as a cumulative density function. **f** , Relative physical error contribution to overall error budget (Methods). **g** , Distribution of detector errors per shot, suggesting the absence of large-scale correlated errors.
Full size image
To correct for the effect of atom loss, we construct so-called superchecks (see ref. 39.") and Methods) by multiplying stabilizers around the lost atom to recover error information, which results in a suppressed detected error probability (Fig. 2b). These observations indicate that using the loss information in decoding can greatly improve QEC performance, as predicted theoretically8."),9."). To take advantage of these features, we use most-likely error (MLE)9."),40.") and machine learning decoders32.") trained on simulated and experimental data, incorporating loss information into both (Methods).
We now characterize repeated QEC performance as a function of the code distance _d_ (ref. 41.")). We find that _d_ = 5 has a 2.14(13)× lower error per round than _d_ = 3, indicating below-threshold behaviour for this four-round characterization circuit (Fig. 2d) (see also discussion below). In particular, we find that the loss information and machine learning decoding improve the QEC performance by a factor of 1.73(13)× compared with conventional methods. Although our observations show below-threshold behaviour for repeated QEC rounds, theoretically the threshold can get worse by about 1.15× in the limit of many repeated rounds and by around 1.1× when incorporating about 1 transversal gate per QEC round (Methods and Extended Data Fig. 8). The error per round is 0.62(3)% for _d_ = 5 and reduces towards 0.1% per round on shots with no qubit loss (Fig. 2e), consistent with a _p_ 3 scaling and roughly half of our errors being loss.
These observations are consistent with numerical simulations using a simple empirical error model based on separately characterized error rates (see error budget in Fig. 2f and Supplementary Information). We further note that our observed distribution of errors per shot is closely consistent with these simple simulations with uncorrelated Pauli-type and loss-type errors, suggesting the absence of large-scale correlated errors in the system. We observe that time correlations are almost fully diminished when postselecting on no qubit loss, indicating that almost all leakage (>80%; Methods) corresponds to atom loss, whereas leakage to other hyperfine states seems to be suppressed. This observation suggests that various scattering channels42.") naturally loss-convert, probably because of anti-trapping of metastable states.
## Stabilizer measurement during logic operations
We next extend repeated QEC to logical operations by studying two different approaches for realizing quantum logic (Fig. 3a), in which the stabilizer measurements play different roles. In the transversal method, a logical gate is realized by physically transporting and interlacing the data qubits of two surface code blocks, and then applying pairwise entangling gates1."),6."),11."). In the planar setting, logical entanglement is realized by lattice surgery10."), in which a joint logical measurement is performed by ancilla qubits added between the two codes (Fig. 3a,b). To probe these logical operations, in the transversal approach, we apply three rounds of _N_ repeated CNOTs interleaved with two rounds of stabilizer checks. In the lattice surgery approach, we carry out a \\({Z}_{L}^{1}{Z}_{L}^{2}\\) joint logical measurement using two rounds of stabilizer measurements10."). We then measure the \\({X}_{L}^{1}{X}_{L}^{2}\\) and \\({Z}_{L}^{1}{Z}_{L}^{2}\\) parities of the resulting logical Bell state for both methods.
**Fig. 3: Exploring the interplay of logic gates and entropy removal.**

**a** , Atom images showing two-qubit logic gates and stabilizer measurement. Lattice surgery is realized using ancillas to measure the logical product \\({Z}_{L}^{1}{Z}_{L}^{2}\\), and transversal gates are realized by atomic motion. **b** , Quantum circuits for realizing transversal gates and lattice surgery operations. Logical CZ gates are constructed from transversal CNOTs with adjacent Hadamards cancelled. **c** , Dependence of the error of the logic operation on the ancilla measurement error. Lattice surgery errors rapidly worsen with increasing ancilla measurement errors (injected in postprocessing). **d** , _N_ repeated logic operations are interspersed with rounds of QEC stabilizer measurement. Transversal CNOT has a lower error than lattice surgery (left), and has an optimum of roughly three CNOTs per round, as seen most clearly when modest postselection, characterized by acceptance fractions (AF) are used (right). Numerical simulations for lattice surgery (Extended Data Fig. 8d) show a minimum error-corrected fidelity at roughly three rounds for _d_ = 5. Note that error detection is used for lattice surgery in **d** (red marker) to further compensate for having less than  _d_ rounds (Methods).
Full size image
To test the role of stabilizer measurements in both cases, we first introduce additional ancilla measurement errors in postprocessing (Fig. 3c). We observe a lower logical error for transversal gates and that the lattice surgery is significantly more sensitive to injected measurement errors. To explore the interplay of logic gates and entropy removal, we next study the transversal gate performance as a function of the number of repeated CNOT gates per QEC round. We find optimal performance for several CNOTs per QEC round, and using postselection on decoding confidence (Methods), observe that approximately three CNOTs per round is optimal at low error rates (Fig. 3d).
These results highlight several key aspects of FTQC. First, the response to ancilla measurement errors highlights the key distinction between the two approaches: in the transversal gate setting, the logic is realized directly between the data qubits, which store the underlying logical states, and the role of stabilizer measurements is to remove entropy, whereas in lattice surgery, the ancilla measurements directly perform the logic operation and have to be correct. The need for correct stabilizer measurements is the origin of the conventional fault-tolerance assumption of _d_ rounds per QEC cycle6."),10."). Conversely, with transversal operations, the observed optimum at three CNOTs per round corresponds to stabilizer measurements balancing the local entropy generated by the logic gate. This is consistent with theoretical predictions for universal computation with correlated decoding techniques12."),40."),43."). Second, Fig. 3d shows that the error per logical gate depends on the number of gates applied per QEC round. This highlights a key distinction between operations on physical and logical qubits: although physical gate performance can be well-characterized by a single fidelity value _F_ , logical gate performance depends both on the decoding success probability—which reflects the physical entropy of the system, captured by the detector error probability _P_ det—and on how much that entropy increases per logical gate, quantified by Δ _P_ det. We find that a simple model for logical gate fidelity _F_ _L_ , where \\(1-{F}_{L}\propto [{({P}_{\det }+N\Delta {P}_{\det })}^{(d+1)/2}]/N\\), with the measured Δ _P_ det consistent with our physical two-qubit gate error, accurately describes the experimental data (Methods).
## Universality and synthesizing arbitrary unitaries
We now study how to realize arbitrary error-corrected unitary operations. The core ingredient is the Solovay–Kitaev theorem, which states that arbitrary single-qubit rotations can be approximated to exponential precision using only digital gates such as Hadamard _H_ and \\(T={{\rm{e}}}^{-{\rm{i}}\frac{\pi }{8}Z}\\) (a 45° rotation around the _z_ -axis)5."),15."),24."). We note that although the Eastin–Knill theorem prohibits realizing such a universal gate set with unitary transversal operations44."), it can be circumvented by introducing logical measurement, which breaks the unitarity constraint13.").
In our approach, non-Clifford _T_ gates and universal rotations are realized using efficient transversal circuits constructed from teleportation with three-dimensional (3D) codes. Figure 4a shows experimental measurements in which we use encoding circuits (Methods) to deterministically prepare 2D colour codes (Steane codes)2."), and 3D colour codes (Reed–Muller codes), and subject them to global phase rotations _φ_ around the _z_ -axis13."). For comparison, we also show the results of similar measurements for unentangled physical qubits analysed as 3D codes and 3D codes with incorrect values of stabilizers. The various configurations show plateaus in the logical expectation value, and revivals in the stabilizers, for multiples of 90° angles (multiples of 180° for unentangled qubits). Crucially, 3D codes, prepared in the proper entangled states, also exhibit robustness at multiples of 45°, corresponding to their transversal _T_ gate14.").
**Fig. 4: Synthesizing arbitrary-angle rotations with a universal fault-tolerant gate set.**

**a** , Subjecting codes of various dimensionality to global rotations. Plateaus are seen at robust angles at which the stabilizers also revive. The 3D Reed–Muller codes, only with all positive stabilizer signs, have an additional plateau at 45° corresponding to non-Clifford _T_ gates. Curves are normalized to unity maximum expectation (Methods). **b** , Programmable angles _R_(_θ_ ,  _ϕ_) are realized by an alternating sequence of _H_ and _T_ gates. The circuit shows an implementation of such a sequence with _T_ implemented by state preparation and _H_ implemented by quantum teleportation. **c** , Polar angle plots show generated angles using entangled Reed–Muller codes, measured by tomography, for different maximum numbers of _T_ gates. Experimental results are consistent with theory within statistical error. **d** , Experimental results indicate that the minimum separation between generated angles decreases exponentially with the length of the sequence. The inset shows a rescaling in which _ϵ_ is the angular separation from the target angle. The Bloch sphere shows all measured angles. For visual clarity, variable degrees of acceptance fraction are used (Methods).
Full size image
To implement unitary synthesis by the circuit in Fig. 4b, transversal teleportation is used. Specifically, we create multiple Reed–Muller codes in the |_T_ _L_ ⟩ state and by applying logical CZ gates followed by X-basis measurements (with feedforwards applied in-software here), the logical information is teleported with an _H_ gate13."). Figure 4c shows the set of angles generated by the circuit in Fig. 4b using up to three _T_ gates. The resulting logical states span a range of points on the Bloch sphere and match the expected angles with high precision (Methods). We observe that the angular spacing between accessible states shrinks exponentially with the number of _T_ gates. This enables precise synthesis of rotation angles with a polylogarithmic number of steps (Fig. 4d, inset), as expected by the Solovay–Kitaev theorem5."),24."),45.").
These observations demonstrate that teleportation can be used as a powerful tool for universal processing, allowing precise small-angle rotations to be built from digital gates. Although the circuit realized here is fully transversal, the measurement, decoding and logical feedforward ensure that the logical information propagates unitarily, whereas the physical-level dissipation serves to correct errors. Extended Data Fig. 9 explores universality with transversal CNOTs and code switching between 2D and 3D codes, again finding that the underlying source of universality is the measurement of the 3D code. Moreover, we note that the role of stabilizers differs fundamentally when generating logical magic. Whereas for Clifford circuits, stabilizer measurements are used to remove entropy, for transversal _T_ gates, correct stabilizer signs (for example, +1 eigenvalues) are essential for realizing non-Clifford operations (Fig. 4a). This observation shows that physical entanglement is directly required for logical magic. This can be understood by the fact that, although logical Pauli states such as |+_L_ ⟩ are eigenstates of operators _X_ _L_ =  _X_ 1 _X_ 2 _X_ 3 …, which is a tensor product of physical operators, states such as |_T_ _L_ ⟩ are eigenstates of \\(\frac{1}{\sqrt{2}}({X}_{1}{X}_{2}{X}_{3}\ldots +{Y}_{1}{Y}_{2}{Y}_{3}\ldots )\\), involving a superposition spanning the code that is necessarily entangled. This observation has fundamental implications: for example, an error-corrected Bell inequality test (involving T-basis measurements) requires a high degree of in-block entanglement. In Extended Data Fig. 9f, we perform such an error-corrected Bell inequality test and measure a CHSH inequality of \\(1.99(3)\times \sqrt{2}\\), saturating the quantum bound46.").
## Deep circuits at constant entropy
We now explore the ability to perform deep-circuit quantum computation at the logical level. An important requirement is that the processor is kept at a constant entropy5.") (Fig. 5a), necessitating that physical errors do not accumulate. This is challenging because computation inevitably introduces errors in the physical qubit state, apart from increasing entropy in the other degrees of freedom, such as the atomic motional state. To ensure that all types of physical error are removed and that computation is kept at constant entropy, we again leverage transversal teleportation13."),18."),19."),20."). In this approach (detailed below), the logical information propagates throughout the circuit, whereas the physical errors are left behind. Measuring this block then enables qubit reset, re-cooling and re-initialization of the physical atoms. After that, the block is prepared again in a low-entropy state and is then used for subsequent teleportation steps.
**Fig. 5: Architecture for constant entropy computation.**

**a** , Illustration of processes for removing entropy generated by computation. Logical teleportation is used to ensure all types of physical error are removed (Fig. 6e). **b** , Rabi oscillations measured using the same atoms for 150 cycles of non-destructive measurement and re-initialization. Each curve shows a single experimental run, averaged over 200 atoms in parallel. 3D cooling methods are used in this subplot because coherence does not need to be preserved. **c** , Local cooling with 1D PGC and electromagnetically induced transparency (EIT). The finite magnetic field is compensated by applying a relative detuning between the two circularly polarized counterpropagating beams, lending to a rotating frame in which the effective field is zero. The atom loss and temperature are constant as a function of time and recover to a steady state within one cycle after applying a perturbation (turning off cooling on one layer) to the system (dashed line). **d** , Additional shielding of the data qubits is provided by a 1,529-nm shielding laser, which rapidly suppresses decoherence induced by the imaging (resonance is at 1,529.365 nm).
Full size image
To realize constant entropy operation during deep quantum circuits, the atomic internal states, temperature and atom filling need to be re-initialized during the computation. To achieve this, we combine our non-destructive internal state readout (Fig. 1b) with non-destructive imaging that also re-cools the atom. Although laser cooling is typically achieved using 3D beams in zero magnetic field, we implement a new method that enables high-fidelity imaging and cooling operating with focused 1D beams in a finite _B_ -field (required for atomic qubit control)47."),48.") (Fig. 5c). We further protect coherence of data qubits in the nearby storage zone by applying a 1,529-nm shielding beam49.") (Fig. 5d and Extended Data Fig. 4). Moreover, the missing atoms in the array are refilled with atoms from the atomic reservoir (Fig. 5a). With all these methods combined, in Fig. 5c, we measure the performance when subjecting the atoms to all the operations (except entangling gates) in a 27-layer circuit, explained below. For instance, by applying a perturbation on the fifth cycle, we find that the atomic filling and temperature quickly recover to a steady state. We find that the 1D cooling methods nearly reproduce the conventional 3D performance, limited by tweezer-depth inhomogeneity (which can be straightforwardly improved; Extended Data Fig. 3). Repeated operation also allows for fast cycle rates; as an example, Fig. 5b shows Rabi calibrations with a 4-ms cycle time.
We now use these tools to implement logical algorithms. Here, we entangle, measure and teleport the logical blocks in alternating A and B groups (Fig. 6a). Within one layer, we bring in a fresh batch of physical qubits (group A) from the readout into the entangling zone to encode them into error-correcting codes and then entangle the code blocks with each other (entangling in the space direction). We then bring group B (already entangled) from storage and perform a transversal entangling gate with the group A block (entangling in time direction). In the spirit of measurement-based quantum computing19."), we then move group B into the readout zone, group A to the storage zone and then measure group B. Group B is then re-initialized, and the whole process is repeated in the next layer.
**Fig. 6: Deep logical circuits at constant entropy.**

**a** , Schematic of a 2D cluster state created from Steane codes in space and time. The same atomic qubits are reused every other time layer for up to 27 layers. **b** , Results of repeated logical state preparation of Steane codes. Stabilizer error is constant as a function of cycle. **c,d** , Logical and physical correlations in 1D (**c**) and 2D (**d**) cluster states. Logical correlations persist while stabilizer error correlations rapidly decay. The depth of constant entropy operation is set by the reservoir depletion; continuous reloading can remove this constraint. See Methods for tabulation of postselection applied here and below. **e** , A circuit diagram showing that logical-level evolution is unitary and allows the logical operator to propagate throughout the algorithm, whereas physical-level evolution is dissipative and does not let physical errors propagate. **f** , High-rate [[16, 6, 4]] codes are entangled in space and time direction. **g** , Logical evolution and physical error removal with [[16, 6, 4]] codes (1D cluster state in time direction). Permutation CNOTs within the block (black curve) extend the correlation length in comparison with non-permuted qubits (Methods). **h** , Entanglement structure in space and time, with up to 96 _d_ = 4 logical qubits active simultaneously. **i** , Logical 2D cluster expectation values (averaged across space and the first nine teleportation layers) as a function of the number of co-propagating logical operators that agree (that is, cluster-state stabilizers have the same outcome for each logical qubit within the block).
Full size image
We first study repeated state preparation of 32 blocks of [[7, 1, 3]] (Steane) codes (16 blocks per alternating group) for up to 27 layers (Fig. 6a) and find that the stabilizer expectation value remains constant as a function of the cycle number (Fig. 6b), indicating a steady-state internal entropy. We note that in these experiments, the fidelity is limited by several suboptimal choices in the circuit design structure (see Methods for details). As an example algorithm, we entangle the [[7, 1, 3]] codes in both the time and space directions to realize 1D and 2D cluster states and probe the resulting correlations19."). Starting with a 1D cluster state in the time direction, Fig. 6c shows the correlations at both the logical level and the physical error level by evaluating the correlator ⟨ _Z_ _i_ _Z_ _j_ ⟩ − ⟨ _Z_ _i_ ⟩⟨ _Z_ _j_ ⟩ between coordinates separated in time (Methods). At the logical-qubit level, we observe the expected correlations between logical outcomes corresponding to successful algorithm evolution, with a decay with distance corresponding to an effective algorithmic error rate that improves with decreasing entropy (corresponding to stricter postselection; Methods). Conversely, for the physical errors, we observe that the correlations are rapidly suppressed. Similar behaviour is found in the 2D cluster state data (Fig. 6d), in which the logical cluster-state stabilizers are finite across both space and time, but the correlations between stabilizer errors are rapidly suppressed. These properties persist until the reservoir begins to run out of atoms. Leveraging the regular transversal measurements, we use data qubit loss detection as well as a recurrent neural network architecture50.") for decoding these algorithms (Methods).
These observations can be understood by considering the processes shown in Fig. 6e, indicating how the transversal teleportation ensures the removal of physical errors. Whereas the decoding and logical teleportation (with feedforward done in-software) maintains unitary evolution and propagates the logical information, the physical errors remain on the previous block (with errors propagated by entangling gates travelling at most one layer). This structure, in which the logical information is natively teleported onto a fresh logical block in the algorithm, thereby ensures that the algorithm proceeds at constant entropy while also performing logic (also leveraged in Fig. 4).
To test this teleportation method for more general encodings, we study high-rate [[16, 6, 4]] codes25."). These high-rate codes29.") have a complex structure that would generally require intricate circuit structuring to ensure leakage removal7."),9."). By contrast, by directly using the teleportation procedure described above we find (Fig. 6g, blue curve) that in a temporal 1D cluster state, the logical information propagates, whereas the physical errors are suppressed with a rate similar to the simpler [[7, 1, 3]] Steane codes. These high-rate codes also enable new opportunities for realizing quantum algorithms. For example, the permutation CNOT operation can enable entangling logical qubits within the same block simply through re-indexing physical qubits, thereby extending the correlation length (Fig. 6g, black curve).
We also explore 2D entanglement of the [[16, 6, 4]] blocks (with up to 16 blocks at a time), realizing the entangled structure shown in Fig. 6h. Figure 6i shows the 2D logical cluster state stabilizers as a function of postselection on shots for which the co-propagating logical operators agree (that is, the cluster state stabilizers have the same outcome for each logical qubit within the block). We find that this procedure further improves algorithm performance. This is because the logical operators—although independent degrees of freedom—are supported on the same physical qubits. Although these easily attained in-block correlations are algorithmically useful (as illustrated using [[8, 3, 2]] codes in ref. 11.")), generating this logical entanglement is possible only because the logical operators overlap, which is enabled by the underlying physical entanglement (Methods).
## Discussion and outlook
We now turn to a discussion of our key observations. First, our experiments show an intricate interplay between quantum logic operations and entropy removal: understanding their relationship enables syndrome extraction to be applied only where necessary (Figs. 1–6) and also clarifies entropy-related aspects of logical gate performance (Fig. 3). Second, we find that physical entanglement should be deployed judiciously in the fault-tolerant systems. Although techniques such as transversal gates and high-rate encoding reduce the physical entanglement required for a given amount of logical operations (Figs. 3 and 6f–i), logical magic states demand enforcing precise entanglement structure (Fig. 4). Third, we observe that logical teleportation can be a central mechanism for FTQC18."). This teleportation enables universality even with fully transversal operations (Fig. 4) and offers a native path to physical error removal in deep-circuit protocols, including those involving high-rate codes, allowing direct data qubit detection (including atom loss events) to be effectively used in the decoding algorithms (Figs. 2 and 6). Beyond these architectural insights, we also observe several fundamental physics aspects of QEC. Although previous work has connected quantum contextuality (involving _T_ -basis measurements) with computational hardness51."), our results indicate additional links to the essential entanglement required for the QEC (Fig. 4 and Extended Data Fig. 9). These observations point towards a deeper understanding of how to protect algorithmic outputs and facilitate the realization of complex, deep-circuit quantum algorithms.
Although the present-day experiments demonstrate QEC performance a factor of about 2 below key thresholds, large-scale computation will greatly benefit from reducing physical errors (Fig. 2f). Based on our observations, we estimate that an additional three- to five-fold physical error reduction can be achieved by direct improvements in single-qubit operations, improved calibration (Fig. 5b) and a four times increase in entangling laser power36.") (Methods). Although machine learning decoding is found to be both effective for entropy removal performance (Fig. 2) and simple algorithms (Fig. 6), and fast (about 1 μs per shot, batched on a GPU; Methods), more work is required to ensure scalability of this powerful method32."). Moreover, although the maximum circuit depth here is limited by a depleting atomic reservoir, in a complementary experiment conducted in a separate apparatus, coherent continuous operation on more than 3,000 atomic qubits52.") is demonstrated by continuous atom reloading53."),54."), with techniques fully compatible with the methods presented here. Taken together, these techniques enable advanced experimental exploration of fault-tolerant universal algorithms. Combined with other marked progress with neutral atom systems55."),56."),57."),58."),59."),60."), these developments demonstrate that these systems are uniquely positioned for experimental realizations of deep-circuit FTQC.
## Methods
### System overview
To carry out the present experiments, several key upgrades have been made. We provide here an overview of the experimental system (Extended Data Fig. 1).
A cloud containing millions of cold 87Rb atoms is loaded in a magneto-optical trap inside a glass vacuum cell. The Rb atoms are then loaded stochastically into programmable, static arrangements of 852-nm traps generated with an SLM (Hamamatsu X13138-02), and then rearranged with a set of 852-nm moving traps generated by a pair of crossed acousto-optic deflectors (AODs, DTSX-400, AA Opto-Electronic) to realize defect-free arrays61."),62."),63."). We use D1 lambda-enhanced grey-molasses cooling to achieve a loading efficiency of 75% (ref. 64.")). Atoms are imaged with a 0.65-NA (numerical aperture) objective (Special Optics) onto a CMOS camera (Hamamatsu ORCA-Quest C15550-20UP), chosen for fast electronic readout times. The qubit state is encoded in _m_ _F_ = 0 hyperfine clock states in the 87Rb ground-state manifold, with _T_ 2 > 1 s (refs. 35."),65.")), and fast, high-fidelity single-qubit control is executed by two-photon Raman excitation35."),66."). A global Raman path illuminating the entire array is used for global rotations (Rabi frequency of about 0.5 MHz, resulting in around 5 μs rotations with composite pulse techniques35.")) as well as for dynamical decoupling throughout the entire circuit (typically 1 global π pulse per movement). For this work, we upgrade our microwave source (Rohde and Schwarz, SMW200A) and increase our intermediate-state detuning to 550 GHz (measured scattering error of 5 × 10−5 per robust SCROFULOUS pulse). Fully programmable local single-qubit rotations are realized with the same Raman light but redirected through a local path, which is focused onto targeted atoms by an additional set of 2D AODs. To realize high-fidelity, programmable single-qubit pulses, we have made upgrades to our single-qubit addressing to use direct Raman X-type rotations (see section ‘Local single-qubit gate details’). Entangling gates (270-ns duration) between clock qubits are performed with fast two-photon excitation using 420-nm and 1,013-nm Rydberg beams to _n_ = 53 Rydberg states, using a time-optimal two-qubit gate pulse67.") detailed in ref. 36."), in this work, with the 420-nm laser red-detuned by 4.8 GHz from the intermediate state. During the computation, atoms are rearranged with the AOD traps to enable arbitrary connectivity35."). An important upgrade in this work is the ability to perform non-destructive qubit readout, enabling loss detection as well as qubit reuse. We realize this with a 1D optical lattice16."), which pins one of two spin states, use optical tweezers to separate the pinned and unpinned states and then image the atom position. To further enable mid-circuit qubit measurement and reuse on large arrays, we develop methods of low-loss, high-fidelity qubit readout and re-initialization, while only needing moderate trap depths (see below). We use these techniques here for reusing atoms and extending the depth of error-corrected computation.
The quantum circuits are programmed with a control infrastructure consisting of five arbitrary waveform generators (AWG) (Spectrum Instrumentation), as shown in Extended Data Fig. 1b, synchronized to less than 10-ns jitter. The two-channel rearrangement AWG is used for real-time rearrangement, the two channels of the Rydberg AWG are used for entangling gate pulses and for local SLM detunings, the four channels of the Raman AWG are used for IQ (in-phase and quadrature) control of a 6.8-GHz source35."),66.") (the global phase reference for all qubits) and pulse-shaping of the global and local Raman driving, the two channels of the Raman AOD AWG are used for displaying tones that create the programmable light grids for local single-qubit control, and the two channels of the Moving AOD AWG are used for controlling the positions of all atoms during the circuit.
In this work, we realize circuits as long as 1.1 s for the experiments in Figs. 5 and 6. To realize this with the AWGs, we generate a memory segment for one circuit layer for the Moving AWG, Rydberg AWG and Raman AOD AWG, and then loop these identical memory segments for each layer. This is complicated for the Raman AWG as phase continuity needs to be ensured, and so, for simplicity in this work, we program the whole Raman waveform directly. We fill the entire memory of the Spectrum AWG, and this is what limits our experiments to 27 layers here (and then we choose an appropriately sized reservoir to have atoms for that many layers). Future work will benefit markedly from improved waveform streaming.
### Details of processor configuration
Our approach to quantum processing is highly programmable. However, we find that each new atomic layout design behaves slightly differently11."),35."),68."). A close analogy here is that we can design and print a new chip every time we change our processor design, but each one requires its own specific characterization and calibration. We observe that—although each configuration we create can be slightly different and can have its own specific challenges—with sufficient characterization and optimization, we can recover ‘nominal’ performance (that is, consistent with a simple single-qubit and two-qubit error model) and that such a configuration is stable and reproducible once it has been properly set up.
For example, we detail some example circuit configurations that required different degrees of characterization in this work. In the repeated QEC rounds on the surface code, we were careful to engineer the circuit structuring such that the time would perfectly echo on each qubit. This was greatly facilitated by the symmetric four-gate structure of the stabilizer syndrome extraction circuit. For example, although the local Raman pulses are applied row by row, we ensure that the overall amount of time in superposition—although different for each atom—echoes around a central global π pulse. However, although this enabled us to ensure the total time echoed, the specific structuring and parity of pulses prevented us from ensuring the overall atomic trajectory echoed11."). As such, we had to be more careful with homogenizing the AOD trap power over the surface code region. Conversely, to realize the programmable hypercube codes, we confined ourselves to the general encoding circuit in which even the total time did not echo on each qubit, which thereby greatly affected performance. These illustrate that each circuit we realize is different and, although we find it is always possible to achieve correct, ‘nominal’ fidelities, sometimes our layout and circuit design require multiple iterations to find a suitable approach.
We now detail some more specific aspects of the processor designs used in this work.
#### Surface code
For surface code experiments (Figs. 1–3), the same static traps are used for mid-circuit storage of ancilla blocks and for readout of all qubits at the end of the computation. The readout zone is 12 rows tall (55 μm) with two rows of traps per atom for the lattice readout (Fig. 2a). Six blocks of qubits are interlaced horizontally for storage, corresponding to five 6 × 6 ancilla blocks and one 5 × 5 data block in Fig. 2 and four 6 × 6 ancilla blocks and two 5 × 5 data blocks in Fig. 3. This interlacing ensures that the dimensions of each qubit block is the same in both the readout and entangling zones, preventing heating from AOD intermodulation effects that we observe when compressing or expanding the AOD grid. Two additional columns of traps form a small reservoir used for initial rearrangement, resulting in a total array width of 165 μm.
The 420-nm and 1,013-nm Rydberg tophat beams cover 7 rows of gate sites in the entangling zone and are homogenized to about 1% peak-to-peak variation over a vertical extent of 60 μm. The entangling zone is separated by 40 μm from the storage and readout zone (overlapping in these measurements) to ensure negligible error on stored qubits from the tails of the Rydberg beams.
#### Deep circuits
For deep-circuit experiments (Figs. 5 and 6 and the same configuration used in Fig. 4), we choose the same 60 μm vertical extent for the entangling zone as above. Within this zone, entangling gates are performed simultaneously on up to 256 qubits across 8 rows and 16 columns of gate sites with a horizontal extent of 175 μm. Below the entangling zone is the readout zone, used for measurement and re-initialization of up to 128 atoms arranged in four rows. This region is illuminated by counterpropagating imaging and cooling beams (beam waist 50 μm) as well as the 1D lattice beams (average waist 60 μm) as shown in Extended Data Fig. 1d.
During mid-circuit imaging, atoms are always held in the storage zone, 50 μm from the entangling zone. To preserve coherence of qubits during the imaging, the storage zone is illuminated by a 1,529-nm shielding beam with a beam waist of 35 μm, matching the vertical extent of the zone. These design parameters ensure both that stored atoms do not pick up errors from Rydberg beams, as described above, and also that negligible 1,529-nm light reaches the readout zone and so does not cause spurious lightshifts on the imaging and cooling transitions (see ‘The 1,529-nm shielding beam’). Finally, the reservoir is located directly below the readout zone and contains up to 196 atoms in six rows.
The trap intensities in the entangling and storage zones are set to half of those in the readout and reservoir zones to improve qubit coherence. This is achieved by modifying the target trap intensities in the trap generation algorithm63."). We centre the array on the zeroth diffraction order of the trap SLM to maximize the deflection efficiency.
In our first attempt at deep-circuit processing, we made multiple processor design decisions that are suboptimal and affected our fidelity, which we list here. There is no fundamental reason for these, and after the implementation of the first circuits here, these can be readily improved for future experiments.
  * Re-initialization with local Raman led to an overly sensitive re-initialization procedure that complicated calibration.
  * Imperfect echoing due to a lack of symmetry in the generalized hypercube encoding circuit led to high sensitivity to trap depth variations.
  * We shifted the trap path, and this led to an exacerbated AOD intermodulation effect that seems to cause significant heating and a reduced _T_ 1.
  * Our SLM array had trap depth inhomogeneity, affecting cooling performance (Fig. 5c) and exacerbating improper echoing issues.
  * The specific Rydberg tophat beams we used here had an exacerbated inhomogeneity of about 2–3% peak-to-peak variation.
  * We found that performance is sensitive to the 1,529-nm beam profile, requiring homogeneous coverage in the storage zone due to complex resonances, while preventing illumination on the readout zone.
  * Magnetic field noise from the current supply affected coherence preservation during the between-layer idle times.

These imperfections limited these deep-circuit measurements in particular, and by fixing them, we can then recover nominal performance, corresponding to operating at about 2× below threshold as measured in Fig. 2. The section ‘Error budget and path to 10× below threshold’ describes expectations on how we can improve this nominal performance further to scales approaching 5–10× below threshold.
### Spin-to-position conversion with a 1D optical lattice
We realize non-destructive qubit readout throughout this work through spin-to-position conversion16."),69."),70."),71.") (Extended Data Fig. 2). A 1D optical lattice is formed by two 795-nm counterpropagating local beams, both sourced from the same titanium:sapphire laser (M Squared) and operated at 50–200 GHz blue-detuned of the D1 line. Both beams are _σ_ − polarized such that |_F_ = 2; _m_ _F_ = −2⟩ is a dark state and |_F_ = 2; _m_ _F_ = +2⟩ experiences a maximum lightshift of approximately 6 MHz, corresponding to approximately 300 kHz trap frequency in one axis. The close detuning is a balance between minimizing off-resonant coupling to the D2 line for the dark state and reducing scattering and heating from the lattice light. As the clock state qubit is used for computation, for readout, we first optically pump |_F_ = 2; _m_ _F_ = 0⟩ into the dark state with 780-nm _σ_ −-polarized light resonant to _F_ = 2 to _F_ ′ = 3, which is co-propagating with one port of the lattice. To suppress the probability of scattering into the dark state during readout, we further transfer |_F_ = 1; _m_ _F_ = 0⟩ to |_F_ = 2; _m_ _F_ = +2⟩ (bright state), which also increases the trap depth. This is achieved either by a coherent Raman transfer or with incoherent _σ_ +-polarized 780-nm repumper from _F_ = 1 to _F_ ′ = 3. We use the former approach in all surface code experiments (Figs. 1c, 2 and 3) and the latter in deep-circuit experiments (Figs. 1b, 4 and 6), finding comparable performance from both methods.
Following these state transfers, the lattice is ramped up adiabatically over approximately 100 μs. AOD tweezers pick up atoms in the dark state and move them by approximately 2 μm over approximately 500 μs; during this, atoms in the bright state are pinned in place by the stronger confinement of the lattice. Finally, the lattice is ramped down and a conventional camera-based readout then images the position of the atom, allowing identification of the spin state as well as loss detection. Using the data in Fig. 1b, we measure an error probability of 0.87(7)% for the dark state, 0.05(5)% for the bright state, and a 0.24(2)% probability of loss. The asymmetric error arises from trade-offs when simultaneously optimizing for loss and readout fidelity and can be tuned to be more balanced. Typically, owing to the pumping fidelity, the dark state error is at least about 0.3% higher than the bright state.
We remark that non-destructive qubit readout has previously been realized using stretched states72."),73."); however, it also requires several times deeper traps than the present approach. More recently, related protocols for fast, high-fidelity readout have been realized across several platforms74."),75."),76."),77.").
### One-dimensional and finite-field operation for imaging and cooling
For local cooling and imaging, we use two counterpropagating 780-nm beams with opposite circular polarization47."),78.") (Extended Data Fig. 3). The beams are red-detuned from _F_ = 2 to _F_ ′ = 3 and have a variable relative detuning; the _σ_ +-polarized beam additionally contains a small repump component. Conventional methods based on polarization-gradient cooling (PGC) require zero magnetic field; however, mid-circuit operation requires a finite magnetic field to maintain the quantum state of active qubits. To this end, we develop a scheme for 1D PGC in a finite magnetic field. PGC is based on a linear polarization rotating along the beam propagation direction, which produces a population imbalance within the hyperfine levels47."); in a finite field, this imbalance is disturbed, and the cooling mechanism breaks down47."). By transforming to a frame in which the polarization rotates in time, a fictitious field appears that cancels the external field and restores the cooling effect. This condition is achieved by detuning the two counterpropagating beams—which are parallel/antiparallel to the external magnetic field—by two times the Zeeman splitting of adjacent _m_ _F_ levels. As shown in Extended Data Fig. 3e, this detuning method works across the full range of magnetic fields studied (up to 8.6 G). Furthermore, it is broadly applicable to finite-field implementation of any 1D technique based on the same polarization configuration used here, for example, grey-molasses cooling64."),79.").
Although this finite-field PGC is sufficient to image without loss, we add a second stage of EIT cooling to further reduce the atom temperature48."). The scheme, shown in Extended Data Fig. 3f, uses the same beams as the PGC imaging and requires only changing to be blue-detuned of _F_ = 2 to _F_ ′ = 2 (by about 80 MHz) and reducing the power in one of the beams. As the cooling is uniaxial, it is a priori unclear if all three motional degrees of freedom can be cooled with these techniques. Using both drop-recapture measurements and adiabatic ramp-down measurements of the atom temperature80."), we probe the radial and axial atom temperature and find them both to be comparable to 3D techniques (Fig. 5c and Extended Data Fig. 3f). Furthermore, the steady-state temperature and loss is set only by the EIT cooling fidelity and is independent of the degree of heating introduced from the previous circuit.
### The 1,529-nm shielding beam
To preserve the coherence of qubits in the storage zone, we illuminate them with a single beam of 1,529-nm light (Extended Data Fig. 4). By coupling the 5 _P_ 3/2 state to the 4 _D_ 5/2 state, we impart a strong Stark shift on the excited 5 _P_ 3/2 state49."). This causes probe light in the readout zone to appear off-resonant to the storage-zone atoms while maintaining qubit information in the hyperfine manifold of the ground state, see Extended Data Fig. 4a. The beam is generated by a Connet CoSF-D series 10W fibre laser and is focused down to an elliptical waist of 35 μm × 65 μm. The shorter waist of the beam is aligned vertically to the centre of the storage zone. We image the beam in a 4f system and apply a knife-edge in the image plane, approximately four beam waists from its centre, to suppress its Gaussian tail. Stray 1,529-nm light, even at low powers, can degrade the imaging quality in the readout zone. We find, therefore, that beam shaping is important for maintaining stable imaging quality and coherence on the storage-zone atoms for the layout of our array.
We measure dephasing of the storage-zone qubits, as a function of detuning from the bare transition, whereas readout-zone qubits are illuminated with local probe and repumper light (Extended Data Fig. 4b). We capture the key features of the spectrum with a simple model in which the additional dephasing at each drive power scales as \\(\exp \left(-\frac{{\varOmega }_{{\rm{probe}}}^{2}{\varGamma }_{{\rm{probe}}}t}{4{\varDelta }_{{\rm{LS}}}^{2}}\right)\\) where _Ω_ probe and _Γ_ probe are the Rabi frequency and scattering rate of the local imaging beams, respectively, _t_ is the illumination time and _Δ_ LS is the calculated lightshift of 5 _D_ 3/2 due to the coupling to 4 _D_ 5/2 and 4 _D_ 3/2. More complex on-resonance or multi-level features are not captured by this simple model and are particularly sensitive at detunings between the resonances of the 4 _D_ levels81."). During all experiments with qubit reuse and local imaging, we address the storage zone at 1,529.49 nm with about 1.2 W. This corresponds to an approximate lightshift of 6 GHz on the 5 _P_ 3/2 state. To further characterize the 1,529-nm laser, we explore varying the detuning of the local imaging light and observe a clear Autler–Townes splitting (Extended Data Fig. 4c). We find that, as expected, the separation of two fitted Lorentzian peaks scales linearly with the square root of the drive power.
### Repeated rearrangement from reservoir
The mid-circuit image identifies the qubit state as well as which atoms are lost. Before rearrangement, the atoms are recombined into their original tweezers, balancing the trap depth between the AOD and SLM tweezers to minimize loss and using cooling throughout. After this recombination, we fill empty sites using the reservoir.
In each round of rearrangement, target rows are refilled sequentially with one parallel step per row. All atoms in each step are sourced from a single reservoir row. We choose efficient horizontal moves and optimize the reservoir-to-target row pairings to minimize travel distance. Finally, as the local imaging beams do not cover the full extent of the reservoir, the reservoir site occupancies are stored from a global image before the circuit begins and used reservoir atoms are tracked in software. This leads to a slowly growing rearrangement infidelity.
### Mid-circuit re-initialization
After qubits have been measured and atom loss refilled, the spin state is re-initialized to reuse the qubit. This local state preparation is performed in the readout zone using a Raman-assisted optical pumping scheme35."),82."). Local Raman is used for the coherent π-pulses, and the local probe beams are used for resonant depumping of the _F_ = 2 manifold. Owing to the close horizontal spacing of traps in the readout zone, we minimize crosstalk between local Raman tweezers by alternating the applied π-pulses between odd and even columns. We perform 24 cycles of pumping per atom over a few hundred microseconds.
### Local single-qubit gate details
Single-qubit gates are performed using Raman transitions as described in ref. 11."), with several changes to allow _X_(_θ_) rotations to be directly implemented with high fidelity. The key challenge for local _X_ gates is ensuring polarization homogeneity, as the Rabi frequency is sensitive to the degree of circularity. We find inhomogeneity both across the array, introduced by a sharp dichroic cut-off noted in ref. 11."), as well as inhomogeneity within each optical tweezer due to polarization breakdown near the tweezer focus. To reduce the first effect, we add a second copy of the dichroic into the path with a half-waveplate between the pair, such that any angle-dependent phase shifts on reflection from the dichroics are equally applied to both the _s_ - and _p_ -polarized components and the polarization remains close to circular. Second, polarization breakdown of a circularly polarized tweezer results in an off-axis fictitious field with components both parallel and perpendicular to the external magnetic field (in the plane of the tweezer focus)83."); the parallel components can drive Raman transitions and result in dephasing of the clock qubit. As the magnitude of the maximum off-axis field falls off linearly with tweezer waist, we mitigate this by increasing the waist to 2.5 μm. Finally, to increase the projection of the Rabi frequency drive along the magnetic field axis, we displace the Raman beam by roughly 1.5 mm within the back aperture of the objective whose size is 5.5 mm, so that the Raman beam comes in at an angle. For all single-qubit gates in this work, we use robust SCROFULOUS pulses84.").
### AOD intermodulation effects
We observe several intermodulation effects from the AODs that can result in degraded performance for specific AOD moves. First, it is important to ensure that the frequency tones in a given AOD axis are in an exact frequency comb, as intermodulation can lead to interference and beating near trap frequencies. Second, we observe here that the relative frequencies of the X-frequency spacing and Y-frequency spacing are also important and that when beat notes of these are near trap frequencies, it can also lead to heating. As such, we now primarily use the AODs for translations, avoiding compressions or expansions of the grid when possible, and choose incommensurate spacings for X and Y to avoid accidental cross-resonances.
### Analysis of error correlations
Correlations in errors, in either space or time, can have important implications on QEC. Here we explain various correlation analyses in our system.
#### De-correlation of global coherent errors by projective measurement
Parallel control enables us to, for example, realize a transversal entangling gate with a single global pulse of our entangling laser11."). We may be concerned that such a global control can lead to globally correlated errors that can affect error correction performance. However, error correction natively de-correlates these errors.
Consider a code block of qubits with X and Z stabilizers. Applying a global _θ_ will map each of the X operators to → (_X_ + i _θ_ _Y_) =  _X_ ⋅ (1 −  _θ_ _Z_). Consequently, measuring the X-basis component of this qubit will probabilistically lead to a Pauli _Z_ error on this site with probability _θ_ 2. Note that, for global rotation _θ_ , the logical operator _X_ _L_ =  _X_ _X_ _XX_ … maps to → (_X_ + i _θ_ _Y_)(_X_ + i _θ_ _Y_)(_X_ + i _θ_ _Y_)(_X_ + i _θ_ _Y_) … =  _X_ _X_ _X_ _X_ … + i _θ_ _Y_ _X_ _XX_ …. + (i _θ_)_d_ _Y_ _Y_ _Y_ _Y_ … . As such, for small _θ_ , logical rotations are exponentially suppressed with the code distance _d_. As such, although all the physical qubits receive a global rotation _θ_ , the logical qubit state does not receive that same rotation, and after syndrome measurements, these errors are converted into incoherent-type errors and can be corrected. This is the basis behind the observed suppression in Fig. 1. In Extended Data Fig. 7b, we further show that the error correction prevents an unintended logical rotation. The logical rotation here is even further suppressed by the random stabilizer signs (below).
#### Role of stabilizer signs under coherent errors
Stabilizer signs affect the response of the logical qubit to global coherent rotations. For transversal non-Clifford gates, deterministic stabilizer eigenvalues (for example, = +1) are necessary to correctly implement the logical gate (Fig. 4). By contrast, Clifford circuits allow the eigenvalues to be either +1 or −1, as the signs can be simply tracked through the circuit, giving freedom to engineer how coherent errors interfere. For example, choosing negative signs can generate decoherence-free subspaces85.") and give greater robustness of the logical operator against coherent errors. The same principle also suppresses logical coherent errors during computation38."). In particular, stabilizer measurement projects the logical state onto a specific stabilizer configuration with random ±1 values, which corresponds to a random configuration of physical _X_ and _Z_ flips, which do not commute with the coherent rotation. On top of the exponential suppression of logical coherent errors, this further results such that the specific rotation angle of scale about  _θ_ _d_ is random on each shot, effectively turning these again into incoherent errors on the logical level.
#### Decay to Rydberg P states
In ref. 36.") (extended data figure 7), we analysed the presence of weak correlations between CZ gate errors seen in a repeated randomized benchmarking sequence, and speculated that the origin of these may be due to decay to atomic Rydberg P states. Concretely, during Rydberg gates, roughly 0.07% of the error budget is decay of Rydberg atoms to adjacent Rydberg P states. These states have a strong, long-ranged interaction with the Rydberg S states that are used for the gates and can thereby affect gates occurring in a different site, and moreover can have lifetimes of more than 100 μs. During repeated benchmarking sequences, such as those in ref. 36."), we have only 4 μs between gates, and consequently, Rydberg P atoms can survive for many layers of gates and corrupt gates in distant sites.
In Extended Data Fig. 6g, we plot the CZ gate fidelity in a repeated benchmarking sequence as a function of the duration between the gates and find that the gate fidelity in this array increases from 99.3% to 99.5% by increasing the duration between gates to 100 μs, as the Rydberg atoms decay or eject during that time. This also implies that the reported gate fidelity in ref. 36.") may have been affected by this effect and thereby underestimating the maximum gate fidelity. Analogously, we observe that this gate fidelity reduction is removed by reducing the atom density. In quantum circuits based on atom motion, the duration between gates is sufficiently long (for example, 400 μs for surface code repeated stabilizer measurements) for these Rydberg P states to decay or eject86."), which natively fixes this issue, and consequently we do not observe these effects during quantum circuits.
#### Surface code measurements
In our repeated QEC on the surface code, we search for unexpected error correlations by plotting the distribution of detector errors in a shot. We find these are closely consistent with the expected distribution as seen by Clifford simulations that assume uncorrelated one- and two-qubit errors. Although these data are composed of only approximately 105 detector rounds (14,855 shots, 96 detectors per shot across five rounds), it is nevertheless indicative of the absence of these events. We have yet to observe error burst events such as those observed in solid-state systems7.").
#### Logical teleportations and deep-circuit measurements
In a physical system, diverse physical errors and imperfections can cause complex correlations. For instance, a leakage event can lead to complex correlations that—without its knowledge—can greatly affect QEC performance. As discussed in the next section, incorporating logical teleportations in an architecture can ensure that these errors are removed. In Fig. 6, we verify that these teleportations rapidly remove errors and ensure that errors are not correlated in either time or space. It is important that the atomic qubits are re-initialized properly for this to work. In Extended Data Fig. 10c,d, we plot the correlations when turning off cooling and sorting and find that correlations in this case do not rapidly decay.
### Loss detection for improved QEC
#### Leakage types with neutral atoms
Leakage errors, which take the qubit out of the two-level computational subspace, are important to account for in error correction. The three dominant leakage errors with neutral rubidium (or other alkali) atoms are as follows:
  * Loss events: these events are when the atom is physically lost from the optical trap. Owing to the blockade nature of the gate, doing a gate with a lost atom simply turns off the gate while still applying gate error (it is identical to the atom being in state |0⟩, which is also dark to the Rydberg laser).
  * Leakage to other hyperfine states in the ground-state manifold: in the limit of a large magnetic field, these states are off-resonant and behave the same as a lost atom (turning off CZ gates). However, they are not detected through loss detection. Moreover, in the practical operating conditions of 8.6 G, the level spacings of 6 MHz (compared with the Rabi frequency of 4.6 MHz) mean that adjacent hyperfine states can still off-resonantly couple to the Rydberg state and could lead to repeated errors.
  * Leakage to Rydberg states: population left in the Rydberg manifold can affect subsequent gates and can lead to large error correlations. For example, many-body Rydberg evolution in dense systems observes the so-called avalanche errors in which a macroscopic fraction of the system has an error87."). In our approach, with a low atomic density and several hundred microseconds between gates, the Rydberg atoms (theoretically) either decay to the ground state or are expelled from the tweezer. In this way, such Rydberg leakage converts into an error within the computational subspace, a leakage into adjacent hyperfine states, or a loss event.

We observe that with several hundred microseconds between gates, the effects of Rydberg leakage are not apparent, and during our repeated QEC data, we observe that our leakage is at least 80% loss (Extended Data Fig. 5b).
#### Effect of loss during repeated QEC
Although losses simply turn off subsequent gates, these lead to distinct signatures that are important to account for in the QEC design. Whereas ancilla loss is detected in the projective measurement, losing a data qubit corresponds to unknown loss of a degree of freedom from the system39."),88."). Without adjusting the stabilizer measurement pattern to account for such a loss, the ancilla qubits now are measuring operators that anti-commute with each other, and thereby lead to a ‘flickering’ pattern around the lost data atom. This flickering pattern is akin to the expected behaviour in a subsystem code89.") and means that the flickering can continue for arbitrarily long times. Without accounting for the loss, this then appears as strong time correlations that we observe in Extended Data Fig. 5b.
#### Erasure information and superchecks
It is useful to detect atom loss for two reasons. First, knowing about the lost atom greatly enhances the decoding performance. Although bit-flip and phase-flip errors can be inferred by stabilizers, direct detection of qubit errors—or so-called erasures—means that we already have direct information about where the errors are. This erasure information can thereby greatly improve decoding performance8."),9."),20."),31."),90."),91."). For example, although only (_d_ − 1)/2 Pauli-type errors can be corrected, up to (_d_ − 1) erasure-type errors can be corrected. We do not detect erasures as soon as they occur; instead, we detect them at the final qubit measurement, constituting delayed-erasure information.
Second, although lost atoms lead to anti-commuting stabilizer measurements and a flickering error pattern, these can be accounted for with the use of so-called superchecks39."),88.") (Extended Data Fig. 5a). Although individual stabilizer checks around a lost atom are anti-commuting, taking products of multiple checks creates superchecks, which again commute with each other. We find in Fig. 2b that these superchecks are able to remove the sharp rise in detected error that occurs with increasing data loss.
### Decoding
#### MLE and error-model tuning
To decode the surface code experiments in Figs. 1–3, we use the delayed-erasure MLE decoder described in ref. 9."), augmenting the MLE decoder developed in ref. 40.") to leverage loss information. In particular, the MLE decoder takes as input the stabilizer measurements and the probabilities of the physical error sources in the circuit, and outputs the most likely combination of errors consistent with the syndrome. We construct the circuit error model using Stim92.") to initially contain information about the Pauli error sources in the circuit, then update it for each shot to reflect the detected atom losses. In particular, after an atom is lost, all subsequent gates are cancelled, generating different potential errors depending on when the loss occurred. We, therefore, consider all potential locations a qubit loss could have originated (for example, initialization, gates, movement, or idling before measurement), then add each of the resulting error patterns and their probabilities to the error model for that shot. Errors producing the same syndrome are combined into a composite error mechanism, and their probabilities are correspondingly reweighted, as in ref. 92."). Note that this process explicitly accounts for both propagated Pauli errors from the gate cancellations and the invalidation of stabilizers, which are handled using superchecks.
To optimize the performance of the MLE decoder, we fine-tune the probabilities of different error sources in the circuit error model. In particular, we associate each physical operation with both a Pauli and a loss error rate. The error probabilities in these channels are then treated as variables, which we optimize using the covariance matrix adaptation evolution strategy93.") to minimize the logical error rate on a dataset of approximately 10,000 shots (different shots from the final dataset used for evaluating the fidelity).
To quantify the benefit of using loss information, in Fig. 2 the ‘bare MLE’ decoder does not update the circuit error model based on the loss information, and assigns each loss event to a |0⟩ measurement. We find the loss information improves the measured _d_ = 3/_d_ = 5 error ratio from 1.24(5) to 1.69(8).
Finally, we quantify the confidence of the MLE correction for each shot by comparing the probability of the most-likely error _P_ 0 and the probability of the most-likely error that gives the correction to the logical Pauli observable _P_ 1 (refs. 94."),95."),96."),97.")). The more similar these two error probabilities are, the less confident the decoder is in its correction. We can, therefore, postselect on increasing _P_ 0/(_P_ 0 +  _P_ 1) to improve the accuracy of the results, which we use in Fig. 3d when studying repeated logical gates.
#### Machine learning decoder for surface code
We use a fully connected neural network to decode measurement outcomes from the Fig. 2 surface code experiment using machine learning32."),98."),99."),100."). The decoding task is formulated as a supervised binary classification problem: the input features are measurement outcomes from the experiment, and the output is a label indicating whether the initial state was |0 _L_ ⟩ or |1 _L_ ⟩. The machine learning architecture is a fully connected feedforward network comprising four linear layers, each followed by batch normalization and a Gaussian Error Linear Unit (GELU) activation, as shown below:
decoder = nn.Sequential(
nn.Linear(input_size, 1024),
nn.BatchNorm1d(1024),
nn.GELU(),
nn.Linear(1024, 512),
nn.BatchNorm1d(512),
nn.GELU(),
nn.Linear(512, 256),
nn.BatchNorm1d(256),
nn.GELU(),
nn.Linear(256, 1),
nn.Sigmoid()
)
Training proceeds in three stages: raw training, ensembling and fine-tuning.
#### Raw training
We begin by training the decoder on simulated data generated through circuit-level simulations that incorporate both Pauli and loss errors. Measurement outcomes take values of 0, 1 or 2, corresponding to the qubit being in the |0⟩ state, the |1⟩ state or being lost, respectively. These are one-hot encoded, so the feature vector of a given shot is 3 × (number of measurements). To create balanced training data, random software flips are applied with probability 1/2 along the relevant logical operator, yielding ensembles of |0 _L_ ⟩, |1 _L_ ⟩ for the _Z_ memory and |+_L_ ⟩, |− _L_ ⟩ for the _X_ memory. Apart from the raw {0, 1, 2} measurement values, we provide the neural network with calculated detector outcomes and logical operator values. These additional features help the model learn from structured correlations in the data. Detector values are computed as binary parities (0 or 1) over specified stabilizer regions; if a measurement gives a loss (2), it is assigned a value of 0 when computing detector parities. Logical operator values are calculated along each row or column, depending on the basis. We use a hidden layer size of 1,024, the Adam optimizer with an initial learning rate of 10−3, and a weight decay of 10−2. The learning rate is decreased by a factor of 0.3, if the validation loss does not improve for 10 epochs. Training is performed independently for 10 total experimental configurations: two with code distance _d_ = 5 (in the _Z_ and _X_ bases) and eight with _d_ = 3 (covering four spatial quadrants in both bases). In the pre-training phase, each model is trained on 200 million simulated shots and validated on 20 million simulated shots. We find that decoder performance is largely robust to small perturbations in the error model, and thus, precise tuning of simulation parameters is not necessary. For a batch size of about 104 shots, the inference time per shot is 0.33 μs on a GPU (NVIDIA-A100).
Although the machine learning decoder used here is not directly scalable to high-distance codes—for example, requiring re-training for each code distance and specific circuit, with the number of training samples growing exponentially—exploring different extensions of these neural network architectures for scalable decoding is an interesting direction of ongoing research32."),50."),100.").
#### Ensembling
To account for training variability and enhance robustness, we repeat the full training procedure with 10 different random seeds, resulting in 10 independently trained models per experiment. These are ensembled together by computing the geometric mean of their output probabilities. The resulting ensembled machine learning decoder achieves a logical error per round (LEPR) of 0.78(4)% for _d_ = 5 and 1.37(3)% for _d_ = 3.
#### Fine-tuning
To improve decoding performance, we fine-tune each pre-trained decoder on experimental data taken from designated training sets (independent of the final dataset). For the _d_ = 5 decoders, we fine-tune on approximately 37,000 shots per basis. For the _d_ = 3 decoders, we use approximately 2,500 shots per basis, per quadrant. The neural network architecture remains unchanged, and fine-tuning is performed using the Adam optimizer with a learning rate of 10−3 and a weight decay of 8 × 10−2. The resulting ensemble of fine-tuned machine learning decoder achieves an LEPR of 0.71(4)% for _d_ = 5 and 1.33(4)% for _d_ = 3.
#### Hybrid
When comparing the MLE and machine learning decoders, we find they do not predict the same logical state on all shots and, in particular, differ on shots in which one of the decoders has low confidence in its prediction. To further enhance performance, we, therefore, construct a hybrid decoder that combines the output confidences of the ensembled machine learning decoder with those from the delayed-erasure MLE decoder, in which the MLE confidence is derived from comparing the probabilities of the most-likely error and the most-likely error that gives the opposite logical outcome. The final prediction is given by the weighted geometric mean of the two confidence values with weights of 0.4 and 1 for the MLE and machine learning, respectively. This results in a final value for the reported LEPR of 0.62(3)% for _d_ = 5 and 1.33(4)% for _d_ = 3, which corresponds to the machine learning with loss decoder reported in Fig. 2.
#### MLE decoder for lattice surgery
In the lattice surgery experiment (Fig. 3c,d), we perform a joint ZZ measurement using additional stabilizer checks along the common vertical edge between the two surface codes (‘seam’). We start with both codes prepared in |+_L_ ⟩ and perform two rounds of stabilizer checks on the effective _d_ × 2 _d_ surface code lattice, measuring the stabilizer checks of both the codes and the new seam checks in each round. To measure the _Z_ _Z_ parity of the resulting logical Bell state, with the delayed-erasure MLE decoder9."),40."), we use two decoding procedures. First, we use only the ancilla measurements to obtain the result of the lattice surgery \\({Z}_{1}^{L}{Z}_{2}^{L}\\) measurement given by the product of the seam _Z_ stabilizers. Second, we obtain \\({Z}_{1}^{L}{Z}_{2}^{L}\\) directly from the data qubit measurements, using the previous ancilla measurements in decoding. This measures the _Z_ _Z_ parity of the logical Bell state obtained using lattice surgery. Note that the seam checks from the final data qubit measurement are not included. A shot is counted as an error if these two decoding procedures disagree.
To obtain the _X_ _X_ Bell state parity, we measure all data qubits in the _X_ basis and decode the joint \\({X}_{L}^{1}{X}_{L}^{2}\\) operator spanning both codes. The final logical error probability is given by the mean of the _X_ _X_ and _Z_ _Z_ parities.
#### Machine learning decoder for deep circuits
To decode the 1D and 2D cluster states of logical [[7, 1, 3]] and [[16, 6, 4]] codes in Fig. 6, we use a convolutional neural network. As error correlations in the cluster state do not propagate beyond two CZ gates (Fig. 6e), a convolutional window of size 3 is sufficient to capture the relevant correlations. The decoder architecture comprises three components: an encoder, a convolutional block and a readout module. Both the encoder and readout are constructed from linear layers interleaved with GELU activations, with hidden_size = 128.
encode = nn.Sequential(
nn.Linear(input_size, 1024),
nn.GELU(),
nn.Linear(1024, 512),
nn.GELU(),
nn.Linear(512, 256),
nn.GELU(),
nn.Linear(256, hidden_size)
)
readout = nn.Sequential(
nn.Linear(hidden_size*8, 512),
nn.GELU(),
nn.Linear(512, 256),
nn.GELU(),
nn.Linear(256, 128),
nn.GELU(),
nn.Linear(128, out_size)
)
The convolutional block applied between the encoder and readout modules is defined as follows:
conv = nn.Sequential(
nn.Conv2d(hidden_size, hidden_size*2,
kernel_size=3, padding='same'),
nn.GELU(),
nn.BatchNorm2d(hidden_size*2),
nn.Conv2d(hidden_size*2, hidden_size*4,
kernel_size=3, padding='same'),
nn.GELU(),
nn.BatchNorm2d(hidden_size*4),
nn.Conv2d(hidden_size*4, hidden_size*8,
kernel_size=3, padding='same'),
nn.GELU(),
nn.BatchNorm2d(hidden_size*8),
)
For 1D cluster state decoders, we replace the 2D convolutions with 1D convolutions and omit the batch normalization layers.
Training is performed using circuit-level simulations. The decoder is tasked with inferring the signs of the logical cluster state stabilizers, which are of the form _X_ on a given qubit and _Z_ on its neighbours. By performing measurements in alternating _X_ and _Z_ bases, half of the stabilizers can be reconstructed. The remaining stabilizers are recovered by repeating the experiment with the measurement bases swapped. The decoder predicts the stabilizer signs by inferring the initial state of the qubits measured in the _X_ basis. All logical qubits are initialized in the |+_L_ ⟩ state, and software logical _Z_ flips are applied with probability 1/2 to those measured in the _X_ basis, to generate a balanced training set.
The decoder input includes the raw measurement outcomes (0, 1 or loss), detector values computed from the measurements, and the raw logical operator values, similar to the input format used in the surface code decoder. We train four distinct decoders: one for each combination of code type ([[7,1, 3]], [[16, 6, 4]]) and cluster state geometry (1D, 2D). Each model is trained on more than 100 million simulated shots.
For further details on this decoder architecture, and on machine-learning-based decoders for general quantum algorithms, see ref. 50.").
### Benchmarking surface code performance
#### NZNZ stabilizer gate pattern
Here we describe the effective distance, defined as the minimum number of physical errors required to create a logical error, of _d_ rounds of repeated syndrome extraction using alternating N or Z movement patterns (Extended Data Fig. 6d). By alternating gate orderings, the effective distance is close to the optimal value. To see this, note that without alternating orderings, the effective code distance in the rotated surface code is reduced by a factor of 2 because of hook errors6.") (from a theoretical perspective, see discussion at the end). A hook error is a physical error on the ancilla qubit halfway through the stabilizer measurement cycle that propagates onto two data qubits oriented parallel to the corresponding logical operator (for example, _X_ _L_ for a physical _X_ error). One of these propagated data qubit errors is immediately detected, whereas the other is detected in the following round by the next-nearest stabilizer along the direction of error propagation. As a result, if the same gate ordering is used for each round of stabilizer measurements, a sequence of \\(\lceil \frac{d+1}{4}\rceil \\) hook errors, one occurring in each round along the direction of error propagation, can generate a logical error on correction. This issue is circumvented by alternating gate orderings between rounds, as only every other round has the unfavourable propagation. In this case, \\(\frac{d-1}{2}\\) physical errors on consecutive rounds are needed to generate a logical error.
In our experiments in particular, we choose an ordering of NZZrNr, where _r_ represents performing the reverse ordering (Extended Data Fig. 6d). Apart from this structuring helping preserve fault-tolerance against hook errors, we also note that the dominance of _Z_ -type errors means that most errors do not lead to propagated errors between the middle two CZ gate layers. Owing to these reasons, in simulations, we do not observe that having spatially alternating N and Z patterns helps performance (not plotted). Although the _d_ = 3 colour codes studied here could also suffer from hook errors under repeated stabilizer measurement, we similarly expect that they would be robust to these errors with increased code distance. Moreover, we note that as studied in ref. 11."), Steane-style QEC can be effectively used for fault-tolerant syndrome extraction on colour codes in neutral atom systems.
#### Simulations
We perform simulations using the Stim simulation package92."). We sample both Pauli errors and qubit losses. Pauli errors are generated using the sampling routines of Stim, based on circuit-level noise models. Qubit losses are sampled according to the loss probabilities associated with each instruction, and when a loss occurs, subsequent gates acting on the lost qubit are removed to reflect the absence of the qubit. The simulations detect {0, 1, loss} during qubit readout, similar to that in our experiments. For each set of physical parameters, we estimate the logical error rate by Monte Carlo sampling. Logical errors are declared when the prediction of the decoder for the logical observable differs from the true value. See Supplementary Information for details of the noise model, as well as the discussion below.
#### Analysis of below-threshold performance for deep circuits
In Fig. 2, we perform four rounds of repeated QEC as a benchmark. However, increasing the circuit depth can affect the threshold in various ways, depending on the particular circuit. Extended Data Fig. 8a shows how the LEPR ratio _r_ changes for a single logical qubit as we increase the number of QEC rounds using a theory error model, showing a roughly 17% decrease in _r_ from 4 rounds to 20. Similarly, Extended Data Fig. 8b plots the same quantity for a single logical qubit with an approximate experimental error model, showing an analogous 9% decrease in _r_ from 4 rounds to 50. Furthermore, by interspersing 1 transversal gate every 1 QEC round under an approximate experimental error model, we find the ratio _r_ changes by 2% at 25 QEC rounds. Similarly, previous work with a theory error model has shown that the threshold can change by about 10% with 1 gate per QEC round40."). These simulations indicate that the benchmark studied in Fig. 2 is representative, but depending on context, it can be different on the scale of about 15% for deep circuits. We note, however, that in transversal architectures, the prevalence of logical gate teleportations (for example, in magic state distillation and angle synthesis) makes it such that there are typically only several stabilizer measurement rounds before transversal measurement.
Our benchmark results are comparable to those in ref. 7."). For instance, although a one-to-one comparison is not direct because of the presence of loss information, using the supercheck metric shows a 9.04% mean detector error, comparable to the 8.5–8.7% mean detector error in ref. 7.").
#### Error budget and path to 10× below threshold
To get to algorithmically relevant error rates of about 10−10 (refs. 101."),102.")), a factor of 5–10× below threshold can achieve the required errors with several hundred qubits in a code block103."). Our performance is captured by the error budget in Fig. 2f, which we now describe in further detail.
We first list our single-qubit errors and their possible improvements:
  * Local single-qubit gates have approximately 99.9% fidelity, arising from a 0.05% scattering error and residual miscalibrations. Increasing Raman detuning to 2.5 THz will further reduce scattering errors and miscalibrations from the Raman differential light shift, and improving calibration routines can thereby achieve 99.99% fidelity.
  * Our coherence time in 852-nm traps is approximately 1–2 s, depending on the dynamical decoupling sequence applied. Comparable systems have achieved coherence times of 12.6 s with further tweezer detunings57.").
  * We experience a total loss from movement of roughly 1% on the ancilla atoms, arising from transfers and moves between and within the zones. We have previously observed performance in ref. 11.") with transfer-limited loss that would correspond to 0.2% movement loss here, which we speculate arises in the present work from using too high an AOD radiofrequency power. Our repeated QEC sequence also experienced 0.6% background loss from vacuum that can be readily reduced to <0.01% using improved vacuum lifetime and a shorter sequence (for example, about 4 ms cycle times in Fig. 5b).
  * Our lattice readout is now operating with a loss rate of 0.3% and a 99.5% bit-flip error rate. Although a new technique, similar methods in purely lattice systems have achieved fidelities of 99.94% (ref. 16.")).

To improve two-qubit gate performance, an example approach can be :
  * Improve system stability, homogeneity and fast, automated calibration. Although we achieve CZ fidelities of 99.6%, drifts since the last calibration (several days in the context of the surface code benchmarking) often contribute 0.05–0.1% error during final data taking.
  * Use the smooth-amplitude gate, higher magnetic fields or the 6 _P_ 1/2 intermediate state to suppress coupling to the adjacent _m_ _j_ = +1/2 state, reducing the error from about 0.06–0.15% to near-zero.
  * Increase both 420-nm and 1,013-nm Rydberg laser power by a factor of 4×. This can allow for simultaneous (numbers are from simulation, see ref. 36.")): 
    * increase Rydberg detuning from 4.8 GHz in the present work to 9.6 GHz, reducing scattering error from 0.094% to 0.052%; and
    * decrease gate time from 270 ns to 135 ns, reducing Rydberg _T_ 1 error from 0.113% to 0.057% and reducing dephasing error from 0.134% to 0.034%.

These can reduce the two-qubit gate error from roughly 0.5% to 0.15% through simple system improvements. The AOM pulse profile should be compensated for realizing these gate times, and the fractional inhomogeneity of the 1,013-nm beam needs to be improved by the corresponding increase in power.
Altogether, by reducing single-qubit gate errors by a factor of 5× and improving two-qubit errors from 0.5% to 0.15% through the improvements listed, operation at roughly 8× below threshold would be achieved. The two-order-of-magnitude increase in cycle rate shown in Fig. 5b will be instrumental to enabling these improvements. These estimates highlight that straightforward improvements can lend the performance required for large-scale computation. We also emphasize that this performance needs to be tested and optimized in deep-circuit settings.
### Processor clock speed
Future operation will eventually be affected by the speed of operations, once algorithms with, for example, trillions of operations need to be realized101."),102."). In the present work, we do not optimize for clock speed, and often choose slower speeds for our components so that they can function reliably without detailed characterization on existing infrastructure. However, we here report multiple measurements of our circuit durations.
In the repeated surface code experiments in Fig. 2, each QEC round was 4.45 ms. This originated from a 0.47 ms time between gates, and a total of 2.57 ms from moving the ancilla atoms to the storage zone and bringing in the next group to the entangling zone. In the transversal CNOT experiments in Fig. 3, we fix the overall circuit duration (independent of the number of CNOTs) at 17.7 ms, corresponding to the time of the longest circuit of 27 total transversal CNOTs. This corresponds to 0.655 ms per transversal CNOT on average. In the deep-circuit experiments in Fig. 6, our cycle rate was bottlenecked through the use of desktop computers for all data processing for the mid-circuit image analysis and rearrangement, and so we did not attempt to reduce any times. For this reason, each logical teleportation layer was 41.9 ms.
In the repeated Rabi calibration in Fig. 5b, we optimized for speed and achieved a cycle time of 4 ms. Although the imaging here was global as a demonstration of fast calibration, we expect that these speeds can also be achieved in a zoned manner. Destructive measurement can be faster than the qubit reuse approach used here, but the absence of loss information degrades QEC performance (Fig. 2) and further increases required qubit reloading rates for continuous operation. Although non-destructive readout is slower, this may or may not bottleneck operations depending on, for example, when the next non-Clifford operation occurs. Comparing these holistically in the context of a whole architecture is an important avenue of future research.
We thereby expect that, with optimization for speed in the deep-circuit context and various simple improvements, we should be able to achieve a logical teleportation cycle with a cycle time comparable to the 4-ms repeated Rabi calibration. We emphasize that in a planar architecture, this logical teleportation step involves multiple logical gates and can require several hundreds of QEC rounds for large-distance codes, for example, 200–300 stabilizer measurement rounds. As such, we estimate the present methods are slower by a factor of about 10–20 relative to a conventional planar architecture, associated, for example, with superconducting qubits, with 1 μ _s_ speed per stabilizer measurement cycle7."),101."),104.").
### Physical entropy removal
#### Types of entropy
QEC enables removing entropy from the physical qubits, and this entropy can take on many different forms. As discussed above, error correction such as stabilizer measurement, serves the role of converting generic quantum errors, such as coherent ones, into incoherent bit- and phase-flip errors. Detecting and tracking these errors further removes entropy from the system. Finally, physical systems such as atoms have entropy in other degrees of freedom such as loss, leakage or atom heating. We would like to design our QEC strategy to remove all of these entropy types.
#### Overview of entropy removal methods
Ancilla-based stabilizer extraction, as used in Figs. 1–3, is one form of entropy removal, in which stabilizer information is mapped onto the ancilla and then the ancilla is measured. Shor-style syndrome extraction operates by entangling ancillas into a GHZ state and extracting the stabilizer in a single step1."), Steane-style syndrome extraction operates by creating an ancilla logical qubit and extracting stabilizers by a transversal CNOT105."), and measurement-based quantum computing (MBQC)-style syndrome extraction operates by sequential entanglement with adjacent layers19."),20."),106."). Leveraging teleportation native to the algorithm is another related method of entropy removal without ever ‘directly’ correcting the initial logical qubit block after it was used in computation. Although these methods all vary in their specific implementations, their core mechanism of entropy removal is similar. These methods can be used interchangeably depending on specific practical considerations, such as those discussed in the next section.
#### Use of teleportation for ensuring error removal
Logical teleportations are a method to ensure an architecture natively removes physical errors such as bit- and phase-flips, but also physical errors such as loss, leakage and heating19."). In particular, by teleporting a logical qubit from one block to another, the logical information propagates but the physical errors—both Pauli-type and other complex errors—are all left behind. This method ensures errors of all types are removed. Owing to transversal gates leading to only _O_(1) QEC rounds per logic gate, algorithms can be composed of a high density of logical gate teleportations. This highlights that, as shown in Fig. 6, teleportation can perform logical operations while natively removing all these errors without additional overhead. We note that the same behaviour can be achieved in codes with transversal CNOTs with appropriate preparation of basis states or transversal Hadamards, such as in conventional MBQC with surface codes, and is not predicated on having a transversal CZ gate in the code.
An alternative method for removing physical errors is teleportation at the physical level—specifically, by swapping quantum information between a physical data qubit and a physical ancilla. This approach underlies various implementations of leakage reduction units9."),20."),107."),108."),109"). However, it necessitates pairing each data qubit with a dedicated ancilla, which can present challenges. For example, in high-rate quantum LDPC codes encoding many logical qubits, this one-to-one pairing can become increasingly impractical. In general, the number of unpaired data qubits in each round of error correction is lower bounded by _k_ = number of data qubits − number of independent checks, where _k_ is the number of encoded qubits. For example, in hypergraph product codes constructed from (_u_ ,  _v_)-biregular expanders—bipartite graphs in which checks have degree _u_ and bits have degree _v_ —the compact rearrangement scheme of ref. 110.") implies that there will be _O_((_v_ −  _u_)_d_) unpaired data qubits per error-correction cycle, where _d_ is the distance of the code. By contrast, logical-level teleportation is directly accessible in all CSS codes (as they all have a transversal CNOT), as demonstrated in the high-rate [[16, 6, 4]] code in Fig. 6. This analysis highlights that leveraging the transversal teleportations native to an algorithm lends to a robust, low-overhead procedure that ensures all physical errors are removed independent of the specific code.
#### Feedforward in universal processing
Once bit- or phase-flip errors have been detected, a natural question is if they need to be physically corrected in-hardware to return back to a configuration with all stabilizers equal to +1. For conventional computation based on transversal (or planar) Clifford gates, stabilizer measurements, and universality achieved by teleportation of |_T_ _L_ ⟩ states (realized by physical Clifford gates), we do not have to apply these physical qubit corrections. This can be most directly seen by the fact that universal computation on the logical-qubit level is realized by physical Clifford gates18."),103."), and so the Pauli corrections can be deterministically tracked in-software as a Pauli frame update without additional overhead on the decoding.
When realizing transversal non-Cliffords, such as the transversal _T_ gate in the [[15, 1, 3]] Reed–Muller code111."), X Pauli corrections do not commute through, and so in such a case the stabilizers do need to be returned to a deterministic +1 eigenvalue. However, in the results here, for example, we realize deterministic initialization of the Reed–Muller code with +1 eigenvalues as a method of ensuring constant entropy operation, and in this case, mid-circuit correction of individual physical qubits is not required.
In both of these settings, feedforward is required, but only on the logical-qubit level (feedforward _S_ for _T_ teleportation, and feedforward _X_ for _H_ teleportation). We implemented this logical feedforward in figure 4 of ref. 11."), in which feedforward logical _S_ gates were realized to entangle two qubits that did not directly interact.
#### Transversal logic with _O_(1) stabilizer measurements per gate
As in the transversal setting, the role of stabilizer measurements is simply to remove entropy, we do not require the conventional _d_ rounds of stabilizer measurement per logic gate, as shown in Fig. 3. We note that these techniques directly apply for universal computation. Concretely, universal computation is implemented by a transversal Clifford circuit, in which _T_ gates are realized by a transversal teleportation circuit with |_T_ _L_ ⟩ inputs that have already been prepared fault-tolerantly. It has been shown that this universal processing can proceed with _O_(1) stabilizer measurements per transversal gate and that the decoding can also be done efficiently with a decoding complexity that can be even less than the conventional lattice surgery setting12."),40."),43."),112."),113."),114."). As such, our experimental results directly apply to universal computation, under the assumption that the |_T_ _L_ ⟩ inputs are prepared to high quality.
### Methods of universality
#### Universality, transversal gates and Eastin–Knill
Universality means that any unitary can be closely approximated by using sequences of gates from a universal gate set24."). An example universal gate set is {_H_ ,  _T_ , CNOT}. The 2D topological codes can have a discrete gate set of {_H_ ,  _S_ , CNOT}, but cannot transversally implement the _T_ gate. 3D topological codes can have a transversal _T_ gate115."), and the [[15, 1, 3]] 3D colour code, in particular, has a transversal gate set of {CZ, CCZ, CNOT,  _T_}. The Eastin–Knill theorem forbids having a unitary transversal gate set that is universal44."). This is expected, as this would, for example, allow realizing a transversal logical _θ_ rotation by a sequence of transversal operations on the underlying physical qubits, and thereby could not be protected, as it would be sensitive to small imperfections in the physical rotation.
The Eastin–Knill theorem is easily circumvented simply by the introduction of logical measurement, which breaks unitarity and enables universality. This is directly achieved with 3D codes, as realizing a CZ gate between state |_ψ_ _L_ ⟩ and |_+__L_ ⟩, followed by logical measurement and feedforward, teleports a Hadamard gate directly onto |_ψ_ _L_ ⟩. As such, X-basis preparation and X-basis measurements (guaranteed in all CSS codes), combined with transversal CZ gates, can be used to straightforwardly implement a universal gate set of {_H_ ,  _T_ , CNOT} using fully transversal operations. This is the basis behind our implementation of universality in Fig. 4.
We note that in many protocols, universality is directly generated by the measurement of a 3D code. Code switching is an example, in which we switch between codes that have _T_ and _H_ transversal gates116."). For example, we realize a code switching protocol in Extended Data Fig. 9e, in which we teleport a logical T from a 3D [[15, 1, 3]] colour code117.") onto a 2D [[7, 1, 3]] colour code118."). These operations between codes of different dimensionality can often be realized, and here it just involves entangling the 2D surface of the 3D pyramid with the 2D colour code face. Although teleportation onto the 2D colour code now admits transversal _H_ gates, this is anyway already accomplished by the transversal measurement and feedforward from the 3D code.
Although these techniques are easily understood in the context of topological codes, they can also be used for qLDPC or general high-rate codes. In particular, as shown in Fig. 6f, the teleportation protocols are effective for high-rate codes, and in principle, teleportation-based small-angle synthesis could be also used here as well. At the same time, efficient, parallel generation of logical magic in these high-rate codes is an outstanding problem and an active area of theoretical research.
#### Connection to magic state distillation
We note that the protocols studied here are similar to those underlying magic state distillation111."),119."),120."). In the conventional 15-to-1 magic state distillation, 16 surface code logical qubits are entangled in a manner in which the first surface code qubit is entangled with the logical qubit of a [[15, 1, 3]] code made out of surface codes. Subsequently, noisy _T_ gates with some error _p_ are realized on the surface codes by teleportation, which the outer [[15, 1, 3]] code distils into about  _p_ 2 with correction or about _p_ 3 with postselection121."). By measuring the Reed–Muller code, the resulting distilled \\(| T\rangle \\) state is teleported onto the first surface code.
The protocol in Fig. 4 is a more compact representation of the same magic state distillation circuit, but with replacing the inner surface codes with unencoded physical qubits. Whereas in conventional distillation the |_T_ ⟩ is teleported onto the surface code, we note that, for example, in small-angle synthesis with sequential _H_ _THT_ … gates, we do not even need to do the step of teleporting onto the surface code—we can simply leave the |_T_ ⟩ encoded in the Reed–Muller code and then realize a transversal CZ gate between the two concatenated Reed–Muller codes.
#### Small-angle synthesis
Arbitrary logical unitaries can be approximated using a sequence of discrete gates, as stated by the Solovay–Kitaev theorem. Considering the single-qubit gate set {_H_ ,  _T_ ,  _X_} as implemented in Fig. 4, T gates are transversal in the [[15, 1, 3]] and Hadamard gates are implemented by teleportation. Without logical feedforward, this teleportation protocol, using _N_ > 0 T gates, randomly synthesizes one of 2(_N_ −1) possible rotations with equal probability. The remaining angles plotted in Fig. 4c are related by a final Clifford. Adding the appropriate feedforward at each teleportation step would render this protocol deterministic.
To quantify the fidelity of the produced logical states, here we calculate tr(_ρ_ |_ψ_ ⟩⟨ _ψ_ |), where _ρ_ is the logical density matrix obtained from full state tomography and |_ψ_ ⟩ is the target pure state. Averaged over all generated angles, we find fidelities of 98.98(7)%, 98.2(2)%, 98.9(5)%, and 93.7(1.3)% for _N_ =0, 1, 2 and 3 T gates, respectively. The corresponding acceptance fractions are 29%, 28%, 5.2% and 0.54%.
These protocols are scalable to larger codes and can broadly be understood as the same protocol as 15-to-1 magic state distillation but with the inner code surface codes being of distance _d_ = 1. To improve the performance of this protocol and further suppress errors, we anticipate a path of using concatenated surface codes for building each Reed–Muller code.
### Physical resources for QEC
In this work, we study the relationships of many different physical resources and how they are used in QEC. We overview here some of our observations and discuss how these can be useful for developing future QEC protocols and architectures.
#### Logical entanglement and physical entanglement
In a transversal gate setting, logical entanglement can be generated using only physical entanglement between the code blocks. This is in contrast to lattice surgery, in which entanglement within the blocks is necessary to mediate interaction between non-overlapping logical operators, and so we need a robust entanglement. This is the origin of the sensitivity to measurement errors in the lattice surgery context and the insensitivity to measurement errors in the transversal gate context. Logical entanglement within the code block also plays an interesting part. The [[16, 6, 4]] codes, for example, contain many logical qubits within the block, which can be entangled, but only with a sufficient degree of physical entanglement present (discussion below).
Motivated by these observations, one way to re-frame efficient encodings is to find methods that generate the target logical entanglement with the minimum amount of physical entanglement. To this end, we first explore how the amount of logical entanglement—even generated with techniques such as permutation gates—is bounded by the amount of physical entanglement.
Operator entanglement quantifies the maximum entanglement a gate can produce on separable inputs. For any gate acting on _k_ qubits, the operator entanglement is bounded above by ⌊ _k_ /2⌋. Thus, for a quantum code with parameters [[_n_ ,  _k_ ,  _d_]], the logical operator entanglement satisfies _S_ LO ≤ ⌊ _k_ /2⌋. To characterize the physical entanglement entropy, note that logical operators cannot be supported on any set of _d_ − 1 or fewer physical qubits. Therefore, for any region _A_ with |_A_ | ≤  _d_ − 1, all logical codewords yield identical reduced density matrices on _A_ (not necessarily maximally mixed). We consider these regions to remove state dependence. In stabilizer codes _S_ PS(_A_) = |_A_ | −  _r_ _A_ , where _r_ _A_ counts stabilizers fully supported in _A_ (ref. 122.")). We assume _r_ _A_ = 0 for all |_A|_ ≤  _d_ − 1 (no stabilizer fully inside any correctable region); this holds, for example, for every size—(_d_ − 1) subregion in the [[16, 4, 4]] code. Then _S_ PS(_A_) = |_A|_ , so for |_A|_ =  _d_ − 1, we have _S_ LO ≤  _S_ PS(_A_) whenever ⌊ _k_ /2⌋ ≤  _d_ − 1 (that is, _k_ < 2 _d_ − 1).
Thus, for a [[_n_ ,  _k_ ,  _d_]] code with _k_ < 2 _d_ − 1 and _r_ _A_ = 0 for all |_A_ | ≤  _d_ − 1 (for example, [[16, 4, 4]]), the logical operator entanglement cannot exceed the physical entanglement available in any region of size _d_ − 1.
These observations can have applicability to finding efficient algorithm compilations with high-rate codes and transversal operations, both of which we observe here can reduce the amount of physical entanglement to realize the target logical entanglement. For instance, each transversal CNOT in the [[16, 6, 4]] code generates 16 physical CNOTs worth of entanglement and 6 logical CNOTs worth of entanglement, but realizing in-block permutation CNOTs can generate an additional 4 × 2 logical CNOTs, totalling 14 logical CNOTs worth of entanglement, close to the bound of 16 physical CNOTs.
#### Physical entanglement and logical magic
Although physical entanglement is the underpinning of logical entanglement, it is also the underpinning of logical magic. In particular, we find here that states with logical magic require more in-block entanglement than states without any logical magic. This can be understood by the fact that, whereas logical Pauli states such as |_+__L_ ⟩ are represented by operators _X_ _L_ =  _X_ 1 _X_ 2 _X_ 3… (in CSS codes), which is a tensor product of physical operators, states such as s |_T_ _L_ ⟩ are represented by \\(\frac{1}{\sqrt{2}}({X}_{1}{X}_{2}{X}_{3}\ldots +{Y}_{1}{Y}_{2}{Y}_{3}\ldots )\\), involving a macroscopic superposition of operators spanning the code that is necessarily entangled123."),124."). Analogously, any physical product state that has deterministic _X_ -type stabilizers must have zero expectation value for _Y_ _L_. The need for well-defined stabilizers in both bases is thereby another way to see that the code must be entangled. Similarly, CSS codes are constructed from two classical codes1."),2."),23."),125."), and Pauli states are ‘classical’ in that they store 1 bit of information in one of the two classical codes (and 0 bits in the other), whereas |_T_ ⟩ states truly require both codes.
These observations suggest a potentially more fundamental mechanism of what algorithmic outputs do and do not need full protection. For example, consider making a remote entangled Bell pair. To probe its fidelity with _X_ _L_ _X_ _L_ and _Z_ _L_ _Z_ _L_ entanglement witnesses, then with correlated decoding methods we do not need a high degree of entanglement within the individual code blocks—just between the blocks. However, if we would instead like to perform an error-corrected Bell inequality test46."), to provide evidence that quantum mechanics is real, then we have to measure in the |_T_ ⟩ basis and require the full entanglement within the block. It has been argued that so-called quantum contextuality, which arises from measurements in non-Pauli bases, is the core aspect of quantum mechanics that cannot be described by classical theories126."). Relatedly, theoretical work has shown a connection between contextuality and computational hardness51."), and in this work, we find that both of these are also linked to the minimum amount of entanglement required to perform the requisite error correction. Understanding the essence of these connections may hint at further avenues to reduce resource requirements for protecting the relevant algorithmic outputs. An experimental error-corrected Bell inequality test is shown in Extended Data Fig. 9f.
#### Logical gate fidelity and physical entropy
With physical qubits, which are two-level systems, fidelity is a descriptive and accurate concept, as noise can often be decomposed into realizing either the correct operation or the exact opposite (for example, a bit-flip error). Conversely, logical qubits are many-level systems, and so this property does not hold. This fact is related to our observation in Fig. 3d that the error per logical operation is not constant as a function of the number of applied logical gates. Instead, there is a logical fidelity associated with the probability of decoding correctly103."), which depends on the internal density of errors _p_.
Theoretically, the per-step logical error from decoding scales approximately as \\({P}_{L}\propto {(p/{p}_{th})}^{(d+1)/2}\\) (ref. 103.")). The results shown in Fig. 3d indicate that quantifying logical gate performance should encapsulate \\(\\{{F}_{L}({p}_{\det }),\Delta {p}_{\det }\\}\\), which capture how the logical fidelity _F_ _L_ depends on the internal density of errors _p_ , as well as the increase of the gate to local error density Δ _p_. We study this quantitatively in Extended Data Fig. 7.
### Additional experiment and data analysis details
In Fig. 1d, we prepare either \\(| {+}_{L}\rangle ={| +\rangle }^{\otimes 25}\\) or \\(| {0}_{L}\rangle ={| 0\rangle }^{\otimes 25}\\) and apply up to five rounds of stabilizer measurement followed by measurement in the X or Z basis, respectively. A global _Z_(_θ_) rotation is applied to the data qubits at every gate layer (20 time steps in total). For fewer than five stabilizer measurement rounds, the relevant CZ gates are removed, but single-qubit rotations are still applied. One QEC round has gates in the first round only, 2 QEC rounds has gates in the first and fourth rounds, and 5 QEC rounds have gates in all five rounds. The data are averaged over both initial states and use MLE decoding with a 50% acceptance fraction for visual clarity, as well as pre-selection on perfect initial qubit filling. The right plot uses an injected error of _θ_ /2π = 0.016, and additional error rates are shown in Extended Data Fig. 7b.
No postselection is used in the analysis of the surface code in Fig. 2. Pre-selection of initial qubit rearrangement (standard in the literature) is used. Data in Fig. 2b–d are averaged over |_+__L_ ⟩ and |0 _L_ ⟩, and the distributions in Fig. 2e,g aggregate the two bases. Figure 2b,c plots the detector error probability averaged over all rounds. Figure 2b uses the same data set with shots binned according to data qubit loss. The four metrics are (1) ‘bare’, where loss is converted to qubit state 0, effectively corresponding to no loss detection; (2) ‘detect loss’, where projective measurements whose value is ‘loss’ are not counted erroneously; (3) ‘supercheck’, where stabilizers with a lost data qubit are formed into superchecks for all prior rounds; and (4) ‘postselected’, where detectors involving any lost atoms are ignored. The plots show the mean error of all deterministic detectors (96 per basis). The supercheck error is calculated over all samples per round per basis, and the mean of these eight values is plotted. Superchecks paired to the boundary are removed from the averaging as these return no error by construction; if included, the mean error decreases from 9.0% to 8.8%. The contribution of each supercheck is normalized by the supercheck weight, for example, a weight-6 supercheck contributes an error of 4/6 (to account for the greater amount of information in the check—for example, multiplying checks even in the absence of loss raises the detector error without reducing the amount of information). Without reweighting, the error probability increases to 9.6%.
In Fig. 2d,e, the LEPR is calculated as \\({\rm{LEPR}}=0.5(1-{(1-2{p}_{L})}^{1/r})\\) where _p_ _L_ is the final logical error after _r_ = 4 rounds, same as the definition in ref. 7."). The _d_ = 5 dataset contains 9,021 shots in the X basis and 5,834 in the Z basis. The _d_ = 3 dataset contains 2,523 shots for X and 2,534 for Z (on average per quadrant). To make a _d_ = 3 surface code in each of four possible quadrants, we only remove atoms and do not modify the circuit. The specific circuit for the repeated stabilizer measurement is shown in Extended Data Fig. 6c. Not shown are local Y(_π_) and Y(_π_ /2) gates on the boundary ancillas (see Supplementary Information and Stim circuit). Additionally, local detunings127.") are applied to the lowest row of gate sites (where there are only isolated ancilla qubits) to mitigate inhomogeneity in the 1,013-nm lightshift during entangling gates.
In Fig. 2f, the error budget shows the contributions to the detector error (with loss detection) and is obtained by removing error sources individually from the simulation error model. We obtain a similar error model breakdown by simulating the relative contribution to the logical error. Figure 2g shows the detector distribution with loss detection. Extended Data Fig. 6f compares the bare detector error with the simulation.
See Supplementary Information for the error model, including quantitative error budget and pseudocode for simulation, an animation showing the moves realized experimentally and an annotated version of the raw experimental command strings used to realize the circuit. See ref. 41.") for all raw experimental shots, the analysis notebook and trained machine learning decoders.
All data in Fig. 3 use MLE decoding and are pre-selected on perfect initial qubit filling. In Fig. 3c,d, we prepare logical Bell states using either transversal gates or lattice surgery and measure the mean error in the resulting _X_ _X_ and _Z_ _Z_ parities. The error per logical operation is defined as \\(\varepsilon =0.5(1-{(1-2{p}_{L})}^{1/3N})\\) for _N_ transversal gates per round and Bell state infidelity _p_ _L_ , and _ε_ =  _p_ _L_ for the lattice surgery logical product measurement. In Fig. 3c, the transversal CNOT is shown for three CNOTs per QEC round. For each experimental shot, the measurement error is applied in-software with probability _P_ independent of every ancilla qubit (in which an error on a lost atom does nothing). The modified measurements are then decoded, with the ancilla measurement error in the MLE noise model increased appropriately. An acceptance fraction of 1 is used for the transversal CNOT plots unless otherwise stated. In Fig. 3d, the lattice surgery point uses error detection on the middle three ancillas, each having the same value in both rounds of stabilizer measurement, to compensate for having fewer than _d_ rounds of repeated syndrome measurement for this result. We find in numerical simulations using our experimental error model that the optimal number of QEC rounds for this circuit is approximately 3 (as opposed to 5), and that by using error detection with two rounds, we recover a similar performance to this optimal value found in numerics (Extended Data Fig. 8d). Although transversal operations are sensitive only to space-like errors with correlated decoding, additional time-like errors in lattice surgery lead to the higher logical error and the sensitivity to ancilla measurement studied in Fig. 3c.
To modify the stabilizer signs in Fig. 4a, local π pulses are applied at the end of the encoding circuit. Negative stabilizers correspond to flipped qubits on the four corners of the Reed–Muller tetrahedron. We use a lookup table for decoding and plot all three 3D colour code curves with an acceptance fraction of 46% and the 2D colour code with 74%, corresponding to a rescaling by the number of physical qubits in the code. This slightly sharpens the plateaus, which are otherwise smoothened in the presence of logical Z errors. For postselection, the shots are ordered by the weight of the detected error. To highlight the key features, the curves are further normalized by the purity (Extended Data Fig. 9a, top) and maximum stabilizer expectation value (Extended Data Fig. 9a, bottom), with unnormalized data shown in Extended Data Fig. 9a. Figure 4c uses error detection and plots the angles for ≤ _N_ T gates. All plots are postselected on no loss and perfect initial qubit filling.
In Fig. 5c, we study the atom temperature and loss as a function of cycle using the circuit for state preparation of Steane codes (Fig. 6b) with only entangling gates removed. In the fifth cycle, we turn off all imaging and cooling light. For comparison, the same measurements are repeated with conventional 3D PGC imaging and cooling in place of the local techniques. To extract the atom temperature shown in Fig. 5c (top), we use a drop-recapture measurement after _N_ cycles and fit the resulting loss to a Monte Carlo simulation80."). Shaded regions indicate the range of fitted temperatures due to uncertainty in trap parameters.
The [[7, 1, 3]] and [[16, 6, 4]] codes in Fig. 6, as well as the [[15, 1, 3]] in Fig. 4, are members of the family of quantum Reed–Muller codes based on the hypercube encoding circuit shown in Extended Data Fig. 10a (see also Supplementary Videos; ref. 128.")). For each code, a different pattern of local Y(π/2) pulses is applied, whereas the entangling gate structure is the same; for the 2D [[7, 1, 3]] code, the fourth layer of gates is turned off. Although the encoding circuit alone is not fault-tolerant, a verification protocol128.") or ancilla flag qubits11.") can be directly added for future experiments. In Fig. 6b, groups of 16 independent [[7, 1, 3]] codes are prepared in parallel in each time layer, repeated for 27 layers. The stabilizer error probability as a function of layer is plotted for no loss in the code block.
To characterize the propagation of physical and logical information in deep circuits, we further entangle the codes into 1D and 2D cluster states129."). Starting with two groups of logical qubits, group A and group B in Fig. 6a, these are entangled to form the first two time layers of the cluster state. Owing to the local entanglement structure of a cluster state, group A undergoes no more entangling gates and is idle until its measurement (in the appropriate basis), and thereby the measurement can be performed and the same physical qubits reused to form the third layer of the cluster state (in typical MBQC fashion). Group B can then be measured and reused to form the fourth layer of the cluster state, and so on. This alternating structure is typical in MBQC using cluster states19.").
The physical correlations in Fig. 6c,d,g are calculated as the covariance between errors (stabilizer = −1) on the same stabilizer between codes at different coordinates in the cluster state. The covariance is then averaged across all co-propagating cluster states and the different stabilizers (three for [[7, 1, 3]] and five for [[16, 6, 4]]). The logical correlations in Fig. 6c,g are calculated as the appropriate product of cluster state stabilizers between the two target coordinates (cluster states have stabilizers corresponding to _X_ _i_ _Π_ _j_ _Z_ _j_ where _i_ is a specific site and _j_ is its neighbour). For example, we define ⟨ _Z_ 0 _Z_ 4⟩ ≡ ⟨(_Z_ 0 _X_ 1 _Z_ 2) ⋅ (_Z_ 2 _X_ 3 _Z_ 4)⟩. The single-qubit expectation values ⟨ _Z_ _i_ ⟩ are calculated using a lookup table decoder for [[7, 1, 3]] and raw values for [[16, 6, 4]]. Owing to the underlying assumption of time and space invariance, that is, that correlations depend only on relative coordinates, we truncate time layers in which the reservoir begins to be depleted, and this assumption breaks down. This corresponds to 16 layers for Fig. 6c, 13 layers for Fig. 6d (correlations plot only) and 12 layers for Fig. 6g. This has only a small effect on the measured logical correlations but otherwise leads to a longer tail of physical correlations because atoms are not properly refilled once the reservoir begins depleting.
All logical operators in Fig. 6 are decoded with machine learning, which directly predicts the cluster state stabilizers. The 2D cluster state stabilizers in Fig. 6d use a global acceptance fraction of 0.24%. In Fig. 6c,g, we instead use a global confidence threshold for each curve, which is then converted to a mean acceptance fraction. In this way, each curve corresponds to a constant effective error rate (equivalently, constant effective entropy) for the logical operator independent of its weight, resulting in a reduced acceptance fraction for higher-weight operators. By contrast, fixed-acceptance postselection would bias higher-weight operators to a higher entropy compared with lower-weight operators. The confidence for products of the weight-3 logical stabilizers is given as the geometric mean of the constituent confidences. Figure 6g uses a mean acceptance fraction of 3.4% (same data for both curves). The 2D [[16, 6, 4]] cluster state in Fig. 6i also uses the confidence-based postselection, in which the confidence per cluster state stabilizer is the geometric mean of the six decoded co-propagating 2D cluster states. On top of this decoding postselection, the logical stabilizer expectation value is shown as a function of the minimum number of co-propagating operators, _N_ , with the same measurement outcome. We take the mean of all combinations of choosing _N_ out of 6 such operators.
The permutation CNOT in Fig. 6g is applied in software, and its effect here is to increase the weight of the operator connecting coordinates _t_ _i_ and _t_ _j_ , labelled as an effective separation _i_ −  _j_. Following the definitions in ref. 25."), two permutation CNOTs (swapping a pair of rows and a pair of columns) convert the cluster state stabilizers supported on logical qubits 3–6 from four weight-3 to one weight-3, two weight-6 and one weight-12 operator.
See Supplementary Information for an annotated version of the raw experimental command strings used to realize the circuit.
## Data availability
The data that support the findings of this study are available from the corresponding author upon request. The raw data for the surface code repeated QEC is available online in ref. 41.").
## References
  1. Shor, P. W. Fault-tolerant quantum computation. In _Proc. Annual Symposium on Foundations of Computer Science_ , 56–65 (IEEE, 1996).
  2. Steane, A. Multiple-particle interference and quantum error correction. _Proc. R. Soc. Lond. A_ **452** , 2551–2577 (1996).
Article ADS MathSciNet  Google Scholar
  3. Benioff, P. The computer as a physical system: a microscopic quantum mechanical Hamiltonian model of computers as represented by Turing machines. _J. Stat. Phys._ **22** , 563–591 (1980).
Article ADS MathSciNet  Google Scholar
  4. Preskill, J. Quantum computing in the NISQ era and beyond. _Quantum_ **2** , 79 (2018).
Article  Google Scholar
  5. Aharonov, D. & Ben-Or, M. Fault-tolerant quantum computation with constant error rate. Preprint at arxiv.org/abs/quant-ph/9906129 (1999).
  6. Dennis, E., Kitaev, A., Landahl, A. & Preskill, J. Topological quantum memory. _J. Math. Phys._ **43** , 4452–4505 (2002).
Article ADS MathSciNet  Google Scholar
  7. Google Quantum AI and Collaborators Quantum error correction below the surface code threshold. _Nature_ **638** , 920–926 (2024).
Article ADS  Google Scholar
  8. Wu, Y., Kolkowitz, S., Puri, S. & Thompson, J. D. Erasure conversion for fault-tolerant quantum computing in alkaline earth Rydberg atom arrays. _Nat. Commun._ **13** , 4657 (2022).
Article ADS PubMed PubMed Central CAS  Google Scholar
  9. Baranes, G. et al. Leveraging atom loss errors in fault tolerant quantum algorithms. Preprint at arxiv.org/abs/2502.20558 (2025).
  10. Horsman, C., Fowler, A. G., Devitt, S. & Meter, R.van Surface code quantum computing by lattice surgery. _New J. Phys._ **14** , 123011 (2012).
Article ADS MathSciNet  Google Scholar
  11. Bluvstein, D. et al. Logical quantum processor based on reconfigurable atom arrays. _Nature_ **626** , 58–65 (2024).
Article ADS PubMed CAS  Google Scholar
  12. Cain, M. et al. Fast correlated decoding of transversal logical algorithms. Preprint at arxiv.org/abs/2505.13587 (2025).
  13. Raussendorf, R. Key ideas in quantum error correction. _Philos. Trans. R. Soc. A Math. Phys. Eng. Sci._ **370** , 4541–4565 (2012).
Article ADS MathSciNet  Google Scholar
  14. Bombín, H. Single-shot fault-tolerant quantum error correction. _Phys. Rev. X_ **5** , 031043 (2015).
 Google Scholar
  15. Dawson, C. M. & Nielsen, M. A. The Solovay-Kitaev algorithm. _Quantum Inf. Comput._ **6** , 081–095 (2005).
MathSciNet  Google Scholar
  16. Wu, T.-Y., Kumar, A., Giraldo, F. & Weiss, D. S. Stern-Gerlach detection of neutral-atom qubits in a state-dependent optical lattice. _Nat. Phys._ **15** , 538–542 (2019).
Article CAS  Google Scholar
  17. Gottesman, D. & Chuang, I. L. Demonstrating the viability of universal quantum computation using teleportation and single-qubit operations. _Nature_ **402** , 390–393 (1999).
Article ADS CAS  Google Scholar
  18. Knill, E. Quantum computing with realistically noisy devices. _Nature_ **434** , 39–44 (2005).
Article ADS PubMed CAS  Google Scholar
  19. Raussendorf, R. & Briegel, H. J. A one-way quantum computer. _Phys. Rev. Lett._ **86** , 5188–5191 (2001).
Article ADS PubMed CAS  Google Scholar
  20. Sahay, K., Jin, J., Claes, J., Thompson, J. D. & Puri, S. High-threshold codes for neutral-atom qubits with biased erasure errors. _Phys. Rev. X_ **13** , 041013 (2023).
CAS  Google Scholar
  21. Landauer, R. Is quantum mechanics useful? _Philos. Trans. R. Soc. Lond. A Phys. Eng. Sci._ **353** , 367–376 (1995).
Article ADS MathSciNet  Google Scholar
  22. Landauer, R. Irreversibility and heat generation in the computing process. _IBM J. Res. Dev._ **5** , 183–191 (1961).
Article MathSciNet  Google Scholar
  23. Shor, P. W. Scheme for reducing decoherence in quantum computer memory. _Phys. Rev. A_ **52** , R2493–R2496 (1995).
Article ADS PubMed CAS  Google Scholar
  24. Kitaev, A. Y. Quantum computations: Algorithms and error correction. _Russ. Math. Surv._ **52** , 1191–1249 (1997).
Article MathSciNet  Google Scholar
  25. Reichardt, B. W. et al. Demonstration of quantum computation and error correction with a tesseract code. Preprint at arxiv.org/abs/2409.04628 (2024).
  26. Reichardt, B. W. et al. Fault-tolerant quantum computation with a neutral atom quantum processor. Preprint at <https://arxiv.org/abs/2411.11822> (2024).
  27. Sales Rodriguez, P. et al. Experimental demonstration of logical magic state distillation. _Nature_ **645** , 620–625 (2025).
Article ADS PubMed CAS  Google Scholar
  28. Sivak, V. V. et al. Real-time quantum error correction beyond break-even. _Nature_ **616** , 50–55 (2023).
Article ADS PubMed CAS  Google Scholar
  29. Bravyi, S. et al. High-threshold and low-overhead fault-tolerant quantum memory. _Nature_ **627** , 778–782 (2024).
Article ADS PubMed PubMed Central CAS  Google Scholar
  30. Gidney, C., Shutty, N. & Jones, C. Magic state cultivation: growing T states as cheap as CNOT gates. Preprint at arxiv.org/abs/2409.17595(2024).
  31. Putterman, H. et al. Hardware-efficient quantum error correction via concatenated bosonic qubits. _Nature_ **638** , 927–934 (2025).
Article ADS PubMed PubMed Central CAS  Google Scholar
  32. Bausch, J. et al. Learning high-accuracy error decoding for quantum processors. _Nature_ **635** , 834–840 (2024).
Article ADS PubMed PubMed Central CAS  Google Scholar
  33. Beugnon, J. et al. Two-dimensional transport and transfer of a single atomic qubit in optical tweezers. _Nat. Phys._ **3** , 696–699 (2007).
Article CAS  Google Scholar
  34. Schlosser, M., Tichelmann, S., Kruse, J. & Birkl, G. Scalable architecture for quantum information processing with atoms in optical micro-structures. _Quant. Inf. Process._ **10** , 907–924 (2011).
Article ADS  Google Scholar
  35. Bluvstein, D. et al. A quantum processor based on coherent transport of entangled atom arrays. _Nature_ **604** , 451–456 (2022).
Article ADS PubMed PubMed Central CAS  Google Scholar
  36. Evered, S. J. et al. High-fidelity parallel entangling gates on a neutral-atom quantum computer. _Nature_ **622** , 268–272 (2023).
Article ADS PubMed PubMed Central CAS  Google Scholar
  37. Itano, W. M., Heinzen, D. J., Bollinger, J. J. & Wineland, D. J. Quantum Zeno effect. _Phys. Rev. A_ **41** , 2295–2300 (1990).
Article ADS PubMed CAS  Google Scholar
  38. Bravyi, S., Englbrecht, M., König, R. & Peard, N. Correcting coherent errors with surface codes. _npj Quantum Inf._ **4** , 55 (2018).
Article ADS  Google Scholar
  39. Stace, T. M., Barrett, S. D. & Doherty, A. C. Thresholds for topological codes in the presence of loss. _Phys. Rev. Lett._ **102** , 200501 (2009).
Article ADS PubMed  Google Scholar
  40. Cain, M. et al. Correlated decoding of logical algorithms with transversal gates. _Phys. Rev. Lett._ **133** , 240602 (2024).
Article ADS MathSciNet PubMed CAS  Google Scholar
  41. Bluvstein, D. & Geim, A. A. Surface code data and analysis. _Zenodo_. <https://doi.org/10.5281/zenodo.15685795> (2025).
  42. Cong, I. et al. Hardware-efficient, fault-tolerant quantum computation with Rydberg atoms. _Phys. Rev. X_ **12** , 021049 (2022).
CAS  Google Scholar
  43. Zhou, H. et al. Low-overhead transversal fault tolerance for universal quantum computation. _Nature_ **646** , 303–308 (2025).
Article ADS PubMed CAS  Google Scholar
  44. Eastin, B. & Knill, E. Restrictions on transversal encoded quantum gate sets. _Phys. Rev. Lett._ **102** , 110502 (2009).
Article ADS PubMed  Google Scholar
  45. Aaronson, S. & Gottesman, D. Improved simulation of stabilizer circuits. _Phys. Rev. A_ **70** , 052328 (2004).
Article ADS  Google Scholar
  46. Bell, J. S. On the Einstein Podolsky Rosen paradox. _Phys. Phys. Fiz._ **1** , 195–200 (1964).
MathSciNet  Google Scholar
  47. Walhout, M., Dalibard, J., Rolston, S. L. & Phillips, W. D. _σ_ +–σ− Optical molasses in a longitudinal magnetic field. _J. Opt. Soc. Am. B_ **9** , 1997–2007 (1992).
Article ADS CAS  Google Scholar
  48. Chow, C. H., Ng, B. L., Prakash, V. & Kurtsiefer, C. Fano resonance in excitation spectroscopy and cooling of an optically trapped single atom. _Phys. Rev. Res._ **6** , 023154 (2024).
Article CAS  Google Scholar
  49. Hu, B. et al. Site-selective cavity readout and classical error correction of a 5-bit atomic register. _Phys. Rev. Lett._ **134** , 120801 (2025).
  50. Bonilla Ataides, J. P., Gu, A., Yelin, S. F. & Lukin, M. D. Neural decoders for universal quantum algorithms. Preprint at arxiv.org/abs/2509.11370 (2025).
  51. Howard, M., Wallman, J., Veitch, V. & Emerson, J. Contextuality supplies the ’magic’ for quantum computation. _Nature_ **510** , 351–355 (2014).
Article ADS PubMed CAS  Google Scholar
  52. Chiu, N.-C. et al. Continuous operation of a coherent 3,000-qubit system. _Nature_ **646** , 1075–1080 (2025).
Article PubMed PubMed Central CAS  Google Scholar
  53. Gyger, F. et al. Continuous operation of large-scale atom arrays in optical lattices. _Phys. Rev. Res._ **6** , 033104 (2024).
Article CAS  Google Scholar
  54. Norcia, M. A. et al. Iterative assembly of 171 Yb atom arrays with cavity-enhanced optical lattices. _PRX Quantum_ **5** , 030316 (2024).
Article ADS  Google Scholar
  55. Jenkins, A., Lis, J. W., Senoo, A., McGrew, W. F. & Kaufman, A. M. Ytterbium nuclear-spin qubits in an optical tweezer array. _Phys. Rev. X_ **12** , 021027 (2022).
CAS  Google Scholar
  56. Ma, S. et al. High-fidelity gates and mid-circuit erasure conversion in an atomic qubit. _Nature_ **622** , 279–284 (2023).
Article ADS PubMed CAS  Google Scholar
  57. Manetsch, H. J. et al. A tweezer array with 6100 highly coherent atomic qubits. _Nature_ **647** , 60–67 (2025).
Article ADS PubMed PubMed Central CAS  Google Scholar
  58. Tsai, R. B. S., Sun, X., Shaw, A. L., Finkelstein, R. & Endres, M. Benchmarking and fidelity response theory of high-fidelity Rydberg entangling gates. _PRX Quantum_ **6** , 010331 (2025).
Article ADS  Google Scholar
  59. Muniz, J. A. et al. Repeated ancilla reuse for logical computation on a neutral atom quantum computer. Preprint at arxiv.org/abs/2506.09936 (2025).
  60. Zhang, B. et al. Leveraging erasure errors in logical qubits with metastable 171Yb atoms. Preprint at arxiv.org/abs/2506.13724 (2025).
  61. Barredo, D., De Léséleuc, S., Lienhard, V., Lahaye, T. & Browaeys, A. An atom-by-atom assembler of defect-free arbitrary two-dimensional atomic arrays. _Science_ **354** , 1021–1023 (2016).
Article ADS PubMed CAS  Google Scholar
  62. Scholl, P. et al. Quantum simulation of 2D antiferromagnets with hundreds of Rydberg atoms. _Nature_ **595** , 233–238 (2021).
Article ADS PubMed CAS  Google Scholar
  63. Ebadi, S. et al. Quantum phases of matter on a 256-atom programmable quantum simulator. _Nature_ **595** , 227–232 (2021).
Article ADS PubMed CAS  Google Scholar
  64. Brown, M. O., Thiele, T., Kiehl, C., Hsu, T. W. & Regal, C. A. Gray-molasses optical-tweezer loading: controlling collisions for scaling atom-array assembly. _Phys. Rev. X_ **9** , 011057 (2019).
CAS  Google Scholar
  65. Graham, T. M. et al. Multi-qubit entanglement and algorithms on a neutral-atom quantum computer. _Nature_ **604** , 457–462 (2022).
Article ADS PubMed CAS  Google Scholar
  66. Levine, H. et al. Dispersive optical systems for scalable Raman driving of hyperfine qubits. _Phys. Rev. A_ **105** , 032618 (2022).
Article ADS CAS  Google Scholar
  67. Jandura, S. & Pupillo, G. Time-optimal two- and three-qubit gates for Rydberg atoms. _Quantum_ **6** , 712 (2022).
Article  Google Scholar
  68. Evered, S. J. et al. Probing the Kitaev honeycomb model on a neutral-atom quantum computer. _Nature_ **645** , 341–347 (2025).
  69. Mandel, O. et al. Coherent transport of neutral atoms in spin-dependent optical lattice potentials. _Phys. Rev. Lett._ **91** , 010407 (2003).
Article ADS PubMed  Google Scholar
  70. Weiss, D. S. et al. Another way to approach zero entropy for a finite system of atoms. _Phys. Rev. A_ **70** , 040302 (2004).
Article ADS  Google Scholar
  71. Robens, C., Alt, W., Emary, C., Meschede, D. & Alberti, A. Atomic “bomb testing”: the Elitzur-Vaidman experiment violates the Leggett-Garg inequality. _Appl. Phys. B Lasers Opt._ **123** , 12 (2017).
Article ADS  Google Scholar
  72. Martinez-Dorantes, M. et al. Fast nondestructive parallel readout of neutral atom registers in optical potentials. _Phys. Rev. Lett._ **119** , 180503 (2017).
Article ADS PubMed CAS  Google Scholar
  73. Kwon, M., Ebert, M. F., Walker, T. G. & Saffman, M. Parallel low-loss measurement of multiple atomic qubits. _Phys. Rev. Lett._ **119** , 180504 (2017).
Article ADS PubMed  Google Scholar
  74. Norcia, M. A. et al. Seconds-scale coherence on an optical clock transition in a tweezer array. _Science_ **366** , 93–97 (2019).
Article ADS PubMed CAS  Google Scholar
  75. Huie, W. et al. Repetitive readout and real-time control of nuclear spin qubits in 171 Yb atoms. _PRX Quantum_ **4** , 030337 (2023).
Article ADS  Google Scholar
  76. Scott, J. et al. Laser cooling and qubit measurements on a forbidden transition in neutral Cs atoms. _Phys. Rev. Lett._ **135** , 223403 (2025).
  77. Falconi, A. M. et al. Microsecond-scale high-survival and number-resolved detection of ytterbium atom arrays. _Phys. Rev. Lett._ **135** , 203402 (2025).
  78. Dalibard, J. & Cohen-Tannoudji, C. Laser cooling below the Doppler limit by polarization gradients: simple theoretical models. _J. Opt. Soc. Am. B_ **6** , 2023–2045 (1989).
Article ADS CAS  Google Scholar
  79. Grier, A. T. et al. _Λ_ -enhanced sub-Doppler cooling of lithium atoms in D1 gray molasses. _Phys. Rev. A_ **87** , 063411 (2013).
Article ADS  Google Scholar
  80. Tuchendler, C., Lance, A. M., Browaeys, A., Sortais, Y. R. P. & Grangier, P. Energy distribution and cooling of a single atom in an optical tweezer. _Phys. Rev. A_ **78** , 033425 (2008).
Article ADS  Google Scholar
  81. Šibalić, N., Pritchard, J. D., Adams, C. S. & Weatherill, K. J. ARC: an open-source library for calculating properties of alkali Rydberg atoms. _Comp. Phys. Commun._ **220** , 319–331 (2017).
Article ADS  Google Scholar
  82. Levine, H. et al. Parallel implementation of high-fidelity multiqubit gates with neutral atoms. _Phys. Rev. Lett._ **123** , 170503 (2019).
Article ADS PubMed CAS  Google Scholar
  83. Simon, R., Sudarshan, E. C. G. & Mukunda, N. Cross polarization in laser beams. _Appl. Opt._ **26** , 1589–1593 (1987).
Article ADS PubMed CAS  Google Scholar
  84. Cummins, H. K., Llewellyn, G. & Jones, J. A. Tackling systematic errors in quantum logic gates with composite rotations. _Phys. Rev. A_ **67** , 042308 (2003).
Article ADS  Google Scholar
  85. Debroy, D. M. et al. Optimizing stabilizer parities for improved logical qubit memories. _Phys. Rev. Lett._ **127** , 240501 (2021).
Article ADS PubMed CAS  Google Scholar
  86. Cao, A., Yelin, T. L., Eckner, W. J., Oppong, N. D. & Kaufman, A. M. Autoionization-enhanced Rydberg dressing by fast contaminant removal. _Phys. Rev. Lett._ **134** , 133201 (2025).
Article ADS PubMed CAS  Google Scholar
  87. Festa, L. et al. Blackbody-radiation-induced facilitated excitation of Rydberg atoms in optical tweezers. _Phys. Rev. A_ **105** , 013109 (2022).
Article ADS CAS  Google Scholar
  88. Barrett, S. D. & Stace, T. M. Fault tolerant quantum computation with very high threshold for loss errors. _Phys. Rev. Lett._ **105** , 200502 (2010).
Article ADS PubMed  Google Scholar
  89. Kribs, D., Laflamme, R. & Poulin, D. Unified and Generalized Approach to Quantum Error Correction. _Phys. Rev. Lett._ **94** , 180501 (2005).
Article ADS PubMed  Google Scholar
  90. Scholl, P. et al. Erasure conversion in a high-fidelity Rydberg quantum simulator. _Nature_ **622** , 273–278 (2023).
Article ADS PubMed PubMed Central CAS  Google Scholar
  91. Chang, K. et al. Surface code with imperfect erasure checks. Preprint at arxiv.org/abs/2408.00842 (2024).
  92. Gidney, C. Stim: a fast stabilizer circuit simulator. _Quantum_ **5** , 497 (2021).
Article  Google Scholar
  93. Hansen, N. A global surrogate assisted CMA-ES. In _Proc. 2019 Genetic and Evolutionary Computation Conference_ 664–672 (ACM, 2019).
  94. Hutter, A., Wootton, J. R. & Loss, D. Efficient Markov chain Monte Carlo algorithm for the surface code. _Phys. Rev. A_ **89** , 022326 (2014).
Article ADS  Google Scholar
  95. Bombín, H., Pant, M., Roberts, S. & Seetharam, K. I. Fault-tolerant postselection for low-overhead magic state preparation. _PRX Quantum_ **5** , 010302 (2024).
Article ADS  Google Scholar
  96. Smith, S. C., Brown, B. J. & Bartlett, S. D. Mitigating errors in logical qubits. _Commun. Phys._ **7** , 386 (2024).
Article  Google Scholar
  97. Gidney, C., Newman, M., Brooks, P. & Jones, C. Yoked surface codes. _Nat. Commun._ **16** , 4498 (2025).
Article ADS PubMed PubMed Central CAS  Google Scholar
  98. Krastanov, S. & Jiang, L. Deep neural network probabilistic decoder for stabilizer codes. _Sci. Rep._ **7** , 1103 (2017).
Article  Google Scholar
  99. Baireuther, P., O’Brien, T. E., Tarasinski, B. & Beenakker, C. W. Machine-learning-assisted correction of correlated qubit errors in a topological code. _Quantum_ **2** , 48 (2018).
Article  Google Scholar
  100. Gicev, S., Hollenberg, L. C. L. & Usman, M. A scalable and fast artificial neural network syndrome decoder for surface codes. _Quantum_ **7** , 1058 (2023).
Article  Google Scholar
  101. Gidney, C. & Ekerå, M. How to factor 2048 bit RSA integers in 8 hours using 20 million noisy qubits. _Quantum_ **5** , 433 (2021).
Article  Google Scholar
  102. Beverland, M. E. et al. Assessing requirements to scale to practical quantum advantage. Preprint at arxiv.org/abs/2211.07629 (2022).
  103. Fowler, A. G., Mariantoni, M., Martinis, J. M. & Cleland, A. N. Surface codes: towards practical large-scale quantum computation. _Phys. Rev. A_ **86** , 032324 (2012).
Article ADS  Google Scholar
  104. Zhou, H. et al. Resource analysis of low-overhead transversal architectures for reconfigurable atom arrays. Preprint at arxiv.org/abs/2505.15907 (2025).
  105. Steane, A. M. Active stabilization, quantum computation, and quantum state synthesis. _Phys. Rev. Lett._ **78** , 2252–2255 (1997).
Article ADS CAS  Google Scholar
  106. Briegel, H. J., Browne, D. E., Dür, W., Raussendorf, R. & Van Den Nest, M. Measurement-based quantum computation. _Nat. Phys._ **5** , 19–26 (2009).
Article CAS  Google Scholar
  107. Miao, K. C. et al. Overcoming leakage in quantum error correction. _Nat. Phys._ **19** , 1780–1786 (2023).
Article CAS  Google Scholar
  108. Chow, M. N. H. et al. Circuit-based leakage-to-erasure conversion in a neutral-atom quantum processor. _PRX Quantum_ **5** , 040343 (2024).
Article ADS  Google Scholar
  109. Yu, C.-C., Deng, Y.-H., Chen, M.-C., Lu, C.-Y. & Pan, J.-W. Locating Rydberg decay error in SWAP-LRU. Preprint at arxiv.org/abs/2503.01649 (2025)
  110. Xu, Q. et al. Constant-overhead fault-tolerant quantum computation with reconfigurable atom arrays. _Nat. Phys._ **20** , 1084–1090 (2024).
Article CAS  Google Scholar
  111. Bravyi, S. & Kitaev, A. Universal quantum computation with ideal Clifford gates and noisy ancillas. _Phys. Rev. A_ **71** , 022316 (2005).
Article ADS MathSciNet  Google Scholar
  112. Delfosse, N. & Paetznick, A. Spacetime codes of Clifford circuits. Preprint at arxiv.org/abs/2304.05943 (2023).
  113. Serra-Peralta, M., Shaw, M. H. & Terhal, B. M. Decoding across transversal Clifford gates in the surface code. Preprint at arxiv.org/abs/2505.13599 (2025).
  114. Turner, M. L., Campbell, E. T., Crawford, O., Gillespie, N. I. & Camps, J. Scalable decoding protocols for fast transversal logic in the surface code. Preprint at arxiv.org/abs/2505.23567 (2025).
  115. Kubica, A., Yoshida, B. & Pastawski, F. Unfolding the color code. _New J. Phys._ **17** , 083026 (2015).
Article ADS MathSciNet  Google Scholar
  116. Anderson, J. T., Duclos-Cianci, G. & Poulin, D. Fault-tolerant conversion between the Steane and Reed-Muller quantum codes. _Phys. Rev. Lett._ **113** , 080501 (2014).
Article ADS PubMed  Google Scholar
  117. Bombin, H. & Martin-Delgado, M.A. Topological computation without braiding. _Phys. Rev. Lett._ **98** , 160502 (2007).
  118. Bombin, H. & Martin-Delgado, M.A. Topological quantum distillation. _Phys. Rev. Lett._ **97** , 180501 (2006).
  119. Campbell, E. T., Anwar, H. & Browne, D. E. Magic-state distillation in all prime dimensions using quantum Reed-Muller codes. _Phys. Rev. X_ **2** , 041021 (2012).
CAS  Google Scholar
  120. Howard, M. & Campbell, E. Application of a resource theory for magic states to fault-tolerant quantum computing. _Phys. Rev. Lett._ **118** , 090501 (2017).
Article ADS PubMed  Google Scholar
  121. Litinski, D. A game of surface codes: large-scale quantum computing with lattice surgery. _Quantum_ **3** , 128 (2019).
Article  Google Scholar
  122. Majidy, S., Hangleiter, D. & Gullans, M. J. Scalable and fault-tolerant preparation of encoded _k_ -uniform states. _Phys. Rev. A_ **112** , 042409 (2025).
  123. Korbany, D. A., Gullans, M. J. & Piroli, L. Long-range nonstabilizerness and phases of matter. _Phys. Rev. Lett._ **135** , 160404 (2025).
  124. Wei, F. & Liu, Z.-W. Long-range nonstabilizerness from quantum codes, orders, and correlations. Preprint at arxiv.org/abs/2503.04566 (2025).
  125. Calderbank, A. R. & Shor, P. W. Good quantum error-correcting codes exist. _Phys. Rev. A_ **54** , 1098–1105 (1996).
Article ADS PubMed CAS  Google Scholar
  126. Spekkens, R. W. Contextuality for preparations, transformations, and unsharp measurements. _Phys. Rev. A_ **71** , 052108 (2005).
Article ADS  Google Scholar
  127. Manovitz, T. et al. Quantum coarsening and collective dynamics on a programmable simulator. _Nature_ **638** , 86–92 (2025).
Article ADS PubMed PubMed Central CAS  Google Scholar
  128. Gong, A. & Renes, J. M. Computation with quantum Reed-Muller codes and their mapping onto 2D atom arrays. Preprint at arxiv.org/abs/2410.23263 (2024).
  129. Briegel, H. J. & Raussendorf, R. Persistent entanglement in arrays of interacting particles. _Phys. Rev. Lett._ **86** , 910–913 (2001).
  130. Bonilla Ataides, J. P., Tuckett, D. K., Bartlett, S. D., Flammia, S. T. & Brown, B. J. The XZZX surface code. _Nat. Commun._ **12** , 2172 (2021).
Article ADS PubMed PubMed Central CAS  Google Scholar
  131. Google Quantum AI. Suppressing quantum errors by scaling a surface code logical qubit. _Nature_ **614** , 676–681 (2023).
Article ADS CAS  Google Scholar
  132. Higgott, O. & Gidney, C. Sparse Blossom: correcting a million errors per core second with minimum-weight matching. _Quantum_ **9** , 1600 (2025).
Article  Google Scholar
  133. Haug, T. & Kim, M. S. Scalable measures of magic resource for quantum computers. _PRX Quantum_ **4** , 010301 (2023).
Article ADS  Google Scholar

Download references
## Acknowledgements
We thank H. Levine for technical and scientific discussions as well as detailed feedback on the manuscript; N.-C. Chiu, J. Guo, M. Abobeih, P. Stroganov, L. M. Peters and T. T. Wang for key discussions about continuous operations; and D. Kleppner and R. Laflamme for building scientific foundations and communities in AMO and quantum information that this work builds on. We also thank S. Cantu, C.-F. Chen, S. Choi, J. Cong, M. Devoret, S. Ebadi, M. Endres, H.-Y. Huang, P. N. Jepsen, S. Kolkowitz, A. Kubica, A. Lukin, J. Preskill, H. Pichler, H. Putterman, J. Robinson, P. S. Rodriguez, D. Tan, N. Uğur Köylüoğlu, E. Qiu, T. Šumarac, S. Tsesses, Q. Xu and P. Zoller for their discussions. We acknowledge financial support from the IARPA and the Army Research Office, under the Entangled Logical Qubits programme (cooperative agreement no. W911NF-23-2-0219), the DARPA ONISQ programme (grant no. W911NF2010021) and the MeasQuIT programme (grant no. HR0011-24-9-0359), the US Department of Energy (DOE Quantum Systems Accelerator Center, contract no. 7568717), the Center for Ultracold Atoms (an NSF Physics Frontier Center), the National Science Foundation (grant nos. PHY-2012023, CCF-2313084 and QLCI grant OMA-2120757), the Army Research Office MURI (grant no. W911NF-20-1-0082), Wellcome Leap Quantum for Bio programme, and QuEra Computing. D.B. acknowledges support from The Fannie and John Hertz Foundation. S.J.E. acknowledges support from the National Defense Science and Engineering Graduate (NDSEG) fellowship. G.B. acknowledges support from the MIT Patrons of Physics Fellows Society. A.G. acknowledges support from the IBM PhD Fellowship. J.P.B.A. and A.G. acknowledge support from the Unitary Foundation for developing the machine learning software used in the results. T.M. acknowledges support from the Harvard Quantum Initiative Postdoctoral Fellowship in Science and Engineering. S.F.Y. and A.G. acknowledge the NSF through the HDR Q-IDEAS grant (OAC-2118310). S.M. acknowledges support from the Banting Postdoctoral Fellowship. C.K. acknowledges support from the NSF through a grant for the ITAMP at Harvard University. N.M. acknowledges support by the Department of Energy Computational Science Graduate Fellowship under award no. DE-SC0021110. M.C. acknowledges support from Department of Energy Computational Science Graduate Fellowship under award no. DE-SC0020347. The commercial equipment used in this work does not reflect endorsement by NIST.
## Author information
Author notes
  1. These authors contributed equally: Dolev Bluvstein, Alexandra A. Geim

### Authors and Affiliations
  1. Department of Physics, Harvard University, Cambridge, MA, USA
Dolev Bluvstein, Alexandra A. Geim, Sophie H. Li, Simon J. Evered, J. Pablo Bonilla Ataides, Gefen Baranes, Andi Gu, Tom Manovitz, Muqing Xu, Marcin Kalinowski, Shayan Majidy, Christian Kokail, Nishad Maskara, Elias C. Trapp, Luke M. Stewart, Simon Hollerith, Hengyun Zhou, Susanne F. Yelin, Markus Greiner, Madelyn Cain & Mikhail D. Lukin
  2. California Institute of Technology, Pasadena, CA, USA
Dolev Bluvstein
  3. Department of Physics and Research Laboratory of Electronics, Massachusetts Institute of Technology, Cambridge, MA, USA
Gefen Baranes & Vladan Vuletić
  4. ITAMP, Harvard-Smithsonian Center for Astrophysics, Cambridge, MA, USA
Christian Kokail
  5. QuEra Computing, Boston, MA, USA
Hengyun Zhou
  6. Joint Center for Quantum Information and Computer Science, NIST/University of Maryland, College Park, MD, USA
Michael J. Gullans

Authors
  1. Dolev Bluvstein
View author publications
Search author on:PubMedGoogle Scholar
  2. Alexandra A. Geim
View author publications
Search author on:PubMedGoogle Scholar
  3. Sophie H. Li
View author publications
Search author on:PubMedGoogle Scholar
  4. Simon J. Evered
View author publications
Search author on:PubMedGoogle Scholar
  5. J. Pablo Bonilla Ataides
View author publications
Search author on:PubMedGoogle Scholar
  6. Gefen Baranes
View author publications
Search author on:PubMedGoogle Scholar
  7. Andi Gu
View author publications
Search author on:PubMedGoogle Scholar
  8. Tom Manovitz
View author publications
Search author on:PubMedGoogle Scholar
  9. Muqing Xu
View author publications
Search author on:PubMedGoogle Scholar
  10. Marcin Kalinowski
View author publications
Search author on:PubMedGoogle Scholar
  11. Shayan Majidy
View author publications
Search author on:PubMedGoogle Scholar
  12. Christian Kokail
View author publications
Search author on:PubMedGoogle Scholar
  13. Nishad Maskara
View author publications
Search author on:PubMedGoogle Scholar
  14. Elias C. Trapp
View author publications
Search author on:PubMedGoogle Scholar
  15. Luke M. Stewart
View author publications
Search author on:PubMedGoogle Scholar
  16. Simon Hollerith
View author publications
Search author on:PubMedGoogle Scholar
  17. Hengyun Zhou
View author publications
Search author on:PubMedGoogle Scholar
  18. Michael J. Gullans
View author publications
Search author on:PubMedGoogle Scholar
  19. Susanne F. Yelin
View author publications
Search author on:PubMedGoogle Scholar
  20. Markus Greiner
View author publications
Search author on:PubMedGoogle Scholar
  21. Vladan Vuletić
View author publications
Search author on:PubMedGoogle Scholar
  22. Madelyn Cain
View author publications
Search author on:PubMedGoogle Scholar
  23. Mikhail D. Lukin
View author publications
Search author on:PubMedGoogle Scholar

### Contributions
D.B., A.A.G., S.H.L., S.J.E., T.M., M.X. and M.K. contributed to the building of the experimental setup, performed the measurements and analysed the data. J.P.B.A., G.B., A.G. and M.C. developed and implemented the decoding infrastructure. S.M., C.K., N.M. and H.Z. performed theoretical analysis. E.C.T., L.M.S. and S.H. contributed to atomic replenishment methods. All work was supervised by M.J.G., S.F.Y., M.G., V.V., M.C. and M.D.L. All authors contributed to the project vision and understanding about the physics of fault-tolerance, discussed the results and contributed to the paper. All experimental work was performed at Harvard University.
### Corresponding author
Correspondence to Mikhail D. Lukin.
## Ethics declarations
### Competing interests
M.G., V.V. and M.D.L. are co-founders, M.G., V.V., M.D.L. and H.Z. are shareholders, S.F.Y.’s spouse is a co-founder and shareholder, V.V. is Chief Technology Officer, M.D.L. is Chief Scientist, M.G. is a consultant and H.Z. is an employee of QuEra Computing.
## Peer review
### Peer review information
_Nature_ thanks the anonymous reviewers for their contribution to the peer review of this work. Peer reviewer reports are available.
## Additional information
**Publisher’s note** Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations.
## Extended data figures and tables
### Extended Data Fig. 1 Neutral-atom quantum computing architecture.
**a** , Experimental layout illustrating key optical tools, similar to ref. 11.") with the addition of beams for local cooling, imaging and hiding to enable qubit re-use experiments. **b** , Control infrastructure for programming quantum circuits. The entire waveform for all AWGs (except for rearrangement) is uploaded at the start of each experimental run. For qubit re-use experiments, the Moving, Raman AOD and Rydberg AWGs loop the same memory segment each layer. The full waveform is programmed for the Raman AWG to ensure phase continuity. For mid-circuit rearrangement, waveforms are calculated on-the-fly using a desktop computer and sent to the Rearrangement AWG operated in first-in first-out (FIFO) mode. **c** , Level diagram of the relevant atomic transitions of 87Rb. **d** , Processor layout used for qubit re-use experiments and relevant laser beams. Atoms are arranged into storage, entangling and readout zones, with an additional reservoir for refilling lost atoms mid-computation. The 1529-nm hiding beam illuminates the storage zone to preserve coherence of active qubits during imaging in the readout zone. Parallel two-qubit gates are performed in the entangling zone with global Rydberg beams, and local detunings are optionally applied to selected gate sites using an SLM. The readout zone is illuminated with local beams for 1D PGC imaging and EIT cooling, as well as two counter-propagating lattice beams to form a spin-dependent potential for readout via spin-to-position conversion. The entire array is addressed with global Raman control for dynamical decoupling. The same Raman light is directed through a pair of crossed AODs for local single-qubit gates. Global imaging and lambda-enhanced grey molasses cooling light are used for the initial loading.
### Extended Data Fig. 2 Spin-to-position conversion.
**a** , Level diagram showing the 87Rb hyperfine levels used to engineer a spin-selective one-dimensional optical lattice. **b** , Trapping potentials for the bright and dark states. The dark state only experiences a lightshift from the optical tweezers—allowing the atom to be moved around freely—while the bright state is additionally confined by the optical lattice potential. By using a blue-detuned lattice, atoms are trapped in intensity nodes and so scattering of the lattice light is reduced. **c** , Schematic timeline of spin-to-position conversion. The time to transfer the clock qubit to the bright and dark states for readout is typically on the order of roughly 20  _μ_ _s_ , but for some of our measurements is several milliseconds due to using a slow global rotation of the magnetic field (panel e). See Methods text for additional information. **d** , Transfer of qubit state \\(| 1\rangle \\) to the dark state via resonant optical pumping. **e** , Transfer of qubit state \\(| 0\rangle \\) towards into _m_ _F_ = + 1, + 2 states. This is achieved with either a coherent Raman transfer to _F_ = 2,  _m_ _F_ = + 2 or incoherent pumping with _σ_ +-polarized repumper. Both approaches achieve the same bright state readout fidelity, but in the specific implementation we use here the Raman transfer takes several milliseconds owing to the rotation of the external magnetic field for driving _σ_ transitions (2 and 3). **f** , Quadratic suppression of readout error due to scattering. The bright state transfer ensures that at least two lattice-induced scattering events are required to cause a readout error, which occurs if the AOD tweezer has not yet moved away as the bright state becomes unpinned. Scattering further causes diabatic changes in the depth of the lattice potential and may contribute to atom loss.
### Extended Data Fig. 3 One-dimensional imaging and cooling in finite field.
**a** , Atomic level structure for cooling and imaging of 87Rb. The one-dimensional (1D) techniques here rely on coupling hyperfine states separated by _δ_ _m_ _F_ = 2 with counterpropagating _σ_ ± beams. In a finite magnetic field _B_ _e_ _x_ _t_ , the level degeneracy is lifted by the Zeeman effect; here _μ_ _B_ is the Bohr magneton and _g_ _F_ = 1/2 the Landé factor. **b** , Single-shot local image in 8.6 G external magnetic field. Spin-to-position conversion is used in the readout zone and the reservoir is partially imaged by the tails of the imaging beams. **c** , Example site-averaged imaging histogram in the readout zone. **d** , Schematic timeline of mid-circuit measurement and re-initialization used for deep circuit experiments. Due to latency bottlenecks associated with desktop-computer-based processing of images and rearrangement waveforms, we do not attempt here to optimize any speeds and simply use comfortable parameters. The circuit is 13.5-ms long. Including idle times, the spin-to-position conversion takes 4-ms, imaging takes 10-ms, cooling and re-sorting takes 13.3-ms (≈ 7-ms latency for mid-circuit data processing), and re-initialization takes 1.1-ms. We emphasize however that these speeds can be greatly increased, as studied in the 4-ms-cycle repeated Rabi oscillations of Fig. 5b. **e** , 1D polarization gradient cooling (PGC) in finite magnetic field. Top left: interference between the two counterpropagating _σ_ ± probe beams generates a helix of linear polarization47."). Detuning the two beams rotates the helix such that, in the rotating frame, a fictitious magnetic field appears that cancels the external field and restores the zero-field PGC cooling mechanism. Bottom left: atom loss from 1D PGC light at different relative beam detunings, _Δ_ , in varying external magnetic field. The atoms are illuminated for 10 ms under comfortable imaging parameters. A cooling resonance is observed when _Δ_ matches two times the Zeeman splitting (bottom right). Top right: atom temperature around the cooling resonance in 4.3 G field, obtained from drop-recapture measurements. **f** , 1D electromagnetically induced transparency (EIT) cooling. Top: a strong _σ_ + pump beam is combined with a weak _σ_ − probe beam to drive transitions between quantum harmonic oscillator states of the optical tweezer, cooling the atom. The EIT Fano resonance ensures heating transitions are suppressed48."). Bottom: ramp-down measurement of atom temperature. The SLM trap depth is adiabatically ramped down to ~ 5  _μ_ K and held for 5-ms before being ramped back up; the atom loss probability from this process probes the temperature of all three motional axes80."). Since the EIT cooling resonance is narrow and depends on trap frequency, spatial inhomogeneity in the SLM trap depths translates to inhomogeneous cooling and broadens the temperature distribution. Even so, the coldest sites after 1D PGC imaging and EIT cooling reach lower temperatures than conventional 3D PGC, highlighting the utility of these 1D techniques.
### Extended Data Fig. 4 Atomic physics of hiding beam at 1529-nm.
**a** , Upper panel: the hiding beam is aligned to the storage zone and a knife-edge used to suppress its gaussian-tail in the readout zone. Lower panel shows the relevant atomic levels in 87Rb. The hiding beam couples the excited-to-excited state transition and imparts a 6 GHz light-shift on the 5 _P_ 3/2 state. At this detuning, the 5 _S_ 1/2 ground state polarizability is approximately 2 × 10−5 times smaller49."), thus maintaining coherence in the hyperfine qubit manifold while shifting the transition far off-resonance from the imaging light. **b** , Additional dephasing on atoms in the storage zone due to local imaging beams in the readout zone, for various drive powers and detunings. Here we use 20-ms of illumination and closer probe detuning than in deep circuit experiments. We plot a fit to a simple model (described in the text). For deep circuit experiments, we operate at 16 GHz red-detuned from the bare 5 _P_ 3/2 → 4 _D_ 5/2 transition (not shown). **c** , By scanning the detuning of the probe light, we observe an Autler-Townes (AT) splitting of probe resonance when coupled to the 4 _D_ 5/2-level. For this measurement we operate at a low drive power compared to typical values and the drive detuning is 500 MHz red-detuned from resonance, such that both peaks can be experimentally measured in the limited probe detuning range. The small peak is likely due to leaked light and is not expected. **d** , The measured AT-splitting scales linearly with the Rabi frequency of the drive, or the square root of the drive power. **e** , Level diagram illustrating the coupled three-level ladder system which leads to the emergence of the Autler-Townes feature.
### Extended Data Fig. 5 Characterizing effects of loss and leakage in repeated QEC.
**a** , Superchecks. A lost data qubit results in anti-commuting stabilizers and a flickering error pattern. Producting stabilizers surrounding the lost qubit recovers commuting superchecks. **b** , Detection correlation _p_ _i_ _j_ matrix for five rounds of QEC on a _d_ = 5 surface code. Data qubit errors appear as space-like correlations and ancilla measurement errors as time-like correlations between adjacent layers. Leakage results in additional persistent correlations between QEC rounds. By selecting shots with the fewest lost data qubits, these correlations are suppressed, indicating that leakage is dominated by loss which can be detected. Similarly, selecting shots with the most loss enhances the correlations.
### Extended Data Fig. 6 Additional data for repeated QEC characterization circuit.
**a** , Processor layout for repeated QEC on a _d_ = 5 surface code. The data qubits and one ancilla block are located in the entangling zone (top) and four additional ancilla blocks are in storage (bottom); one ancilla block is unused in the four-round circuit. **b** , Processor layout for repeated QEC on a _d_ = 3 code in one of four possible quadrants. **c** , Circuit for four rounds of QEC. For the XZZX rotated surface code130."), Y(_π_ /2) gates are applied to one data qubit sublattice (A or B) for preparing and measuring in the X or Z basis. The equivalent circuit is obtained for stabilizer measurement of the CSS rotated surface code upon compiling Y(_π_ /2) gates. **d** , Stabilizer gate ordering. The same pattern is used globally in each round. **e** , Detector error probability for _d_ = 5. Faint dashed curves correspond to the 24 individual detectors (12 for the first and last rounds), and solid curves are the mean of all deterministic detectors. In this subfigure only, to illustrate the supercheck error distribution, we assign the error of each supercheck to all detectors from which it is composed, and plot the resulting effective detectors; the overall mean is the average of these individual detector values. The first round has lower error due to the neighboring transversal state preparation. The best detector over the central three rounds after loss postselection has 27% lower error than the overall mean; one atom has anomalously high error in the Z basis. **f** , Comparison to simulation. Left: detector error probability, converting loss to qubit state 0. Right: detection correlation matrix _p_ _i_ _j_131."). Both metrics show good agreement between simulation and experiment in the structure and magnitude of the errors. Simulation reproduces experimental detector error probability, being 10.71(3)% (experiment) and 10.5% (simulation) for the ‘detect loss’ metric. With loss postselection the simulation slightly underestimates the loss-postselected detector error (8.06(4)% compared to ≈ 6.2%). **g** , CZ gate fidelity measured via randomized benchmarking36."). Infidelity due to Rydberg P states is removed by leaving sufficient time or distance between gates. Sparse corresponds to 2x larger separation between gate sites.
### Extended Data Fig. 7 Exploring entropy removal during single- and two-logical-qubit operations.
**a** , Additional data for entropy removal via stabilizer measurement. As studied in Fig. 1d, the final logical error depends on the balance between the injected error rate (corresponding to the injected _θ_ /2 _π_ per time-step) and the entropy removal rate (number of QEC rounds in the fixed total time window). For small injected error, there is an optimal number of QEC rounds (here, 3-4) since stabilizer measurement is imperfect and introduces entropy of its own. The plot uses MLE decoding and an acceptance fraction of 66% to enhance salient features. **b** , Absence of coherent logical error. Using the same error-injection protocol as in (a), the final logical state is measured in both the X and Z basis. With no QEC, the global coherent error results in a coherent logical rotation. With one round of QEC, or more, this coherent rotation vanishes. The stabilizer measurement is performed immediately after transversal state preparation, before the majority of the error is injected, such that the lack of logical rotation compared to no QEC can be attributed to the non-deterministic X(Z) stabilizer signs randomizing the response of the Z(X) logical operator to coherent error. Here we ignore the ancillas in the MLE decoding and use a 50% acceptance fraction. All curves are the average of both bases; for left plot, the measurement is the same basis as preparation, and for the right plot it is the orthogonal basis. **c-e** , Analysis of logical gate performance of two logical qubits undergoing repeated transversal CNOTs and QEC, with the circuit studied in Fig. 3 of main text. **c** , The measured detector error probability increases linearly as a function of number of CNOTs applied in each round. **d** , Logical error probability as a function of number of CNOTs per round. Fits are to a functional form of \\(A\cdot {({p}_{{\rm{qec}}}+N\Delta {p}_{\det })}^{3}\\), where _A_ ,  _p_ qec, and \\(\Delta {p}_{\det }\\) are fitted parameters (blue). Using the fitted values of _p_ qec and \\(\Delta {p}_{\det }\\) in **c** produces the predicted logical error probability \\({P}_{L}({p}_{\det })\\) (red). **e** , Results of **d** divided by total number of CNOT gates. Logical gate fidelity \\({F}_{L}({p}_{\det })\\) is \\(1-{P}_{L}({p}_{\det })/(3N)\\), where 3 is the number of rounds and _N_ the number of gates per round.
### Extended Data Fig. 8 Theoretical characterization of logical-error-per-round ratio.
**a** , Numerical simulations of rotated surface code initialized in \\(| {0}_{L}\rangle \\) undergoing repeated QEC rounds with stabilizer measurement gate ordering in ref. 131."). As a simple model, we apply a theory error channel with error probability _p_ = 0.6%, where qubit resets and measurements experience uniform single-qubit depolarizing noise, CNOT gates are followed by uniform two-qubit depolarizing noise, and data qubits experience an idling single-qubit uniform depolarizing channel during ancilla qubit resets. We plot different LEPR ratios (_r_ _d_ /(_d_ +2) = LEPR(_d_)/LEPR(_d_ + 2)) using the PyMatching decoder132."), observing a change of at most 17% as the number of rounds is increased from four. The LEPR for a circuit with _N_ logical qubits and _n_ QEC rounds is defined as \\(\,{\rm{LEPR}}={P}_{L,\text{max}}(1-{(1-{P}_{L}/{P}_{L,\text{max}})}^{1/n})\\), where \\({P}_{L,\text{max}}=1-\frac{1}{{2}^{N}}\\) is the logical error rate of a fully mixed state. **b** , Numerical simulations of repeated QEC on a single \\(| {+}_{L}\rangle \\) surface code using the same circuit as the _d_ = 5 surface code experiment in Fig. 3 of the main text. We use a simplified error model where we take the experimental error model and then turn all loss rates to 0 and double the Pauli error rates for idle errors, reset, measurement, and gate errors (single and two-qubit gates) on both data and ancilla qubits. We plot LEPR ratios for varying numbers of QEC rounds using an MLE decoder40."), observing changes of at most 9%, indicating that performance remains stable even for deeper circuits. **c** , Numerical simulations for circuits with 25 QEC rounds on four logical qubits, with interleaved transversal gate layers using the approximate experimental error model described above. Half of the qubits, selected uniformly at random, are initialized in \\(| {+}_{L}\rangle \\), while the other half are initialized in \\(| {0}_{L}\rangle \\). Each gate layer consists of random pairing of transversal CNOT gates followed by logical single-qubit Pauli gates selected uniformly at random. After applying the random gate sequence _U_ , the inverse _U_ † is applied, followed by transversal measurement in the same basis as initialization. By varying the number of gate layers interspersed between rounds, the LEPR ratio averaged over ≈ 100 randomly sampled circuits varies by at most 2%. **d** , Numerical simulations of lattice surgery on two rotated surface codes initialized in \\(| {+}_{L}\rangle \\) undergoing up to five rounds of repeated stabilizer measurement with gate ordering taken from _N_ ,  _Z_ ,  _Z_ _r_ ,  _N_ _r_ ,  _N_. We simulate the same protocol studied in Fig. 3 to measure the logical _Z_ _Z_ product, using an experimental error model with loss, and plot the logical error probability in the obtained Bell state. At two rounds, simulation (13.1%) approximately reproduces experiment (15.2(3)%). The minimum error occurs at roughly 3 rounds for _d_ =5, as opposed to 5.
### Extended Data Fig. 9 Universality with 3D codes.
**a** , Codes of various dimensions subject to global rotation. The same data are shown in Fig. 4a of the main text, here plotted without any normalization applied to the logical operator or stabilizer expectation values. **b** , Two-copy measurement of a [[15,1,3]] code after a global rotation133."). The additive Bell magic has a plateau at one unit of magic under a global T. The same magic is obtained by analysing either the underlying physical 15-qubit system or the single logical qubit with error detection. **c** , The encoded logical state is connected via a unitary Clifford decoding circuit to a product state of the encoded state and Pauli inputs on the physical qubits. The Clifford circuit conserves magic and therefore the total physical state and encoded logical state must have the same total magic. This implies that, while 15 physical T’s are applied to the system, only 1 physical T is produced, which can only happen with entanglement. **d** , Atom image of a register of 2D and 3D colour codes. A transversal CNOT can be performed between the face of the [[15,1,3]] code (control) and the [[7,1,3]] (target). **e** , Code switching. \\(| {T}_{L}\rangle \\) is prepared transversally on the 3D [[15,1,3]] code and then measurement and in-software feedforward teleports the logical _T_ onto a 2D [[7,1,3]] code (here also with a _H_); this illustrates the equivalence between code switching protocols and logical teleportation. Error detection is used in both plots. **f** , Error-corrected test of Bell’s inequality46."). We measure _S_ = E(_X_ ,  _T_) + E(_X_ ,  _T_ †) + E(_Y_ ,  _T_) − E(_Y_ ,  _T_ †), where E(A,B) is the expectation value of the Steane and Reed-Muller codes in the A and B bases, respectively, and obtain S = 1.99(3) \\(\times \sqrt{2}\\) with error detection.
### Extended Data Fig. 10 Entropy in deep circuits.
**a** , General hypercube encoding. The same entangling circuit structure is combined with programmable input physical states to prepare [[7,1,3]], [[15,1,3]] and [[16,6,4]] codes (members of the family of quantum Reed-Muller codes128.")). For the punctured codes, either the top or bottom qubit is removed. **b** , Turning off entropy removal mechanisms in the 2D [[7,1,3]] cluster state circuit. In the absence of re-cooling or refilling of loss, physical stabilizer correlations persist in time. Lost atoms are assigned as qubit state 0 for this plot, and only correlations between codes constructed from the same atomic qubits in every other layer are shown. **c,d** Circuit structure and physical error correlations. By replacing CZ gates by CNOT gates in the 1D [[7,1,3]] cluster state circuit, physical errors can propagate beyond a single layer, extending the stabilizer correlations. The product of adjacent stabilizers commutes with these propagated errors, recovering the rapid decay in physical correlations.
## Supplementary information
### Supplementary Information
This file contains five sections: (1) Error model: error model (Supplementary Table I) and pseudocode used for simulations of repeated stabilizer measurement on the surface code (Fig. 2). (2) Repeated QEC stim circuit: Stim circuit for four rounds of stabilizer measurement on a d = 5 surface code, preparing and measuring in the X basis. (3) Repeated QEC experimental command strings: Supplementary Note containing experimental commands used to program the circuit for four rounds of stabilizer measurement on the surface code (Fig. 2), including the Moving, Raman, Raman AOD and Rydberg AWGs. (4) Tesseract code experimental command strings: Supplementary Note containing experimental commands used to program the circuit for a 2D cluster state of [[16, 6, 4]] codes (Fig. 6), including the Moving, Raman, Raman AOD and Rydberg AWGs. (5) Summary of decoders: Supplementary Table II summarizing the decoders and methods of error correction and error detection used throughout the paper.
### Peer Review File
### Supplementary Video 1
Animation illustrating the atom and trap positions used for four rounds of repeated stabilizer measurement on a _d_ = 5 surface (Fig. 2). The static green circles indicate SLM tweezers, red circles are the movable AOD tweezers, and dark circles are individual atoms. The X(Y) tones are indicated by vertical(horizontal) dashed lines and the Y tones by horizontal dashed lines. The power of each tweezer or tone is indicated by the opacity of its marker or line. One unit on the _x_ - or _y_ -axis corresponds to approximately 0.66 μm. A 5 × 5 grid of data qubits is first transferred to the entangling zone. An ancilla qubit block is brought from the storage zone, realize gates with the data qubits for stabilizer measurements, and are then returned to storage. This is repeated for three more blocks of ancilla qubits. Finally, the data qubits are transferred back to storage and all qubits measured by spin-to-position conversion (using two moves).
### Supplementary Video 2
Supplementary Videos 2 and 3 are movies of single atoms (real pictures captured with a microscope objective and CMOS camera), showing the quantum circuit implemented in Fig. 6 to realize teleportation-based algorithms in the space and time directions. Parallel entangling gates are indicated by red ovals. Two groups of qubits, A and B, are in the readout and storage zone, respectively, with additional qubits forming the reservoir. Qubits in group A are moved into the entangling zone and encoded using a hypercube encoding circuit. Transversal gates between codes form a 1D cluster state. Next, group B (already entangled) is entangled with group A to create a 2D cluster state across the space and time directions. Group A is moved to storage, to be entangled with the next cycle, and group B is moved to the readout zone and measured by spin-to-position conversion. For illustrative purposes, each qubit is prepared in |+⟩ and therefore imaged with equal probability in the two tweezer locations (frames are averaged over several shots). Finally, the tweezers are recombined, the atoms are re-cooled, the loss is refilled, and the qubit state is re-initialized. This is one layer. The cycle then repeats 27 times. Supplementary Video 2 shows a teleportation-based logical algorithm with Steane [[7, 1, 3]] codes. Each group consists of 16 code blocks in a 4 × 4 grid, which are entangled into two independent 1D cluster states (eight blocks each) and further into 2D cluster states with adjacent layers in time.
### Supplementary Video 3
Teleportation-based logical algorithm with tesseract, high-rate [[16, 6, 4]] codes. Each group consists of eight code blocks in a 2 × 4 grid, which are all entangled into a 1D cluster state in space and further into a 2D cluster state with adjacent layers in time.
## Rights and permissions
**Open Access** This article is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License, which permits any non-commercial use, sharing, distribution and reproduction in any medium or format, as long as you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons licence, and indicate if you modified the licensed material. You do not have permission under this licence to share adapted material derived from this article or parts of it. The images or other third party material in this article are included in the article’s Creative Commons licence, unless indicated otherwise in a credit line to the material. If material is not included in the article’s Creative Commons licence and your intended use is not permitted by statutory regulation or exceeds the permitted use, you will need to obtain permission directly from the copyright holder. To view a copy of this licence, visit <http://creativecommons.org/licenses/by-nc-nd/4.0/>.
Reprints and permissions
## About this article

### Cite this article
Bluvstein, D., Geim, A.A., Li, S.H. _et al._ A fault-tolerant neutral-atom architecture for universal quantum computation. _Nature_ **649** , 39–46 (2026). https://doi.org/10.1038/s41586-025-09848-5
Download citation
  * Received: 25 June 2025
  * Accepted: 03 November 2025
  * Published: 10 November 2025
  * Version of record: 17 December 2025
  * Issue date: 01 January 2026
  * DOI: https://doi.org/10.1038/s41586-025-09848-5

### Share this article
Anyone you share the following link with will be able to read this content:
Get shareable link
Sorry, a shareable link is not currently available for this article.
Copy shareable link to clipboard
Provided by the Springer Nature SharedIt content-sharing initiative 
### Subjects
  * Atomic and molecular physics
  * Quantum information
  * Qubits

Close banner Close
!Nature Briefing
Sign up for the _Nature Briefing_ newsletter — what matters in science, free to your inbox daily.
Close banner Close
Get the most important science stories of the day, free in your inbox. Sign up for Nature Briefing 
  *[DOI]: Digital Object Identifier
